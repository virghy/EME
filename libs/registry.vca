SccTextX Version 1.0.0.1
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RJL0V1NVV
[CLASS] registry
[CLASSLOC] registry.vcx
[BASECLASS] custom
[OBJNAME] filereg
[START PROPERTIES]
Name = "filereg"
[END PROPERTIES]
[START METHODS]
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*getapplication Retrieves application key.
*getapppath Checks and returns path of application associated with a particular extension (e.g., XLS, DOC).
*getlatestversion Returns latest version for a specified application.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\registry.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] filereg

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RJL0UV82J
[CLASS] registry
[CLASSLOC] registry.vcx
[BASECLASS] custom
[OBJNAME] foxreg
[START PROPERTIES]
Name = "foxreg"
[END PROPERTIES]
[START METHODS]
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*enumfoxoptions 
*getfoxoption Retrieves an option from FoxPro registry settings.
*setfoxoption Sets an option from FoxPro registry settings.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\registry.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] foxreg

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RJL0UXJVX
[CLASS] registry
[CLASSLOC] registry.vcx
[BASECLASS] custom
[OBJNAME] odbcreg
[START PROPERTIES]
Name = "odbcreg"
[END PROPERTIES]
[START METHODS]
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*enumodbcdata Enumerates through ODBC data sources.
*enumodbcdrvrs Enumerates through ODBC drivers.
*getodbcdrvrs Retrieves ODBC drivers.
*loadodbcfuncs Loads ODBC registry functions.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\registry.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] odbcreg

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RJL0UQOZ1
[CLASS] registry
[CLASSLOC] registry.vcx
[BASECLASS] custom
[OBJNAME] oldinireg
[START PROPERTIES]
Name = "oldinireg"
[END PROPERTIES]
[START METHODS]
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*getinientry Retrieves information from INI entry.
*getinisection Retrieves information from INI section.
*loadinifuncs Loads functions needed for reading INI files.
*writeinientry Writes a specific INI entry.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\registry.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] oldinireg

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RJL0U66ZY
[CLASS] custom
[BASECLASS] custom
[OBJNAME] registry
[START PROPERTIES]
Name = "registry"
capppathkey = 
cinidllfile = 
codbcdllfile = 
cregdllfile = 
cvfpoptpath = 
ncurrentkey = 0
ncurrentos = 0
nuserkey = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
IF  .NOT. THIS.LHASDLLLOADED
CLEAR DLLS  'REGOPENKEY'
CLEAR DLLS  'REGCREATEKEY'
CLEAR DLLS  'REGDELETEKEY'
CLEAR DLLS  'REGDELETEVALUE'
CLEAR DLLS  'REGCLOSEKEY'
CLEAR DLLS  'REGSETVALUEEX'
CLEAR DLLS  'REGQUERYVALUEEX'
CLEAR DLLS  'REGENUMKEY'
CLEAR DLLS  'REGENUMKEYEX'
CLEAR DLLS  'REGENUMVALUE'
ENDIF
ENDPROC
**
PROCEDURE Error
LPARAMETERS NERROR, CMETHOD, NLINE
THIS.LHADERROR = .T.
= MESSAGEBOX(MESSAGE())
ENDPROC
**
PROCEDURE closekey
= REGCLOSEKEY(THIS.NCURRENTKEY)
THIS.NCURRENTKEY = 0
ENDPROC
**
FUNCTION setregkey
LPARAMETERS COPTNAME, COPTVAL, CKEYPATH, NUSERKEY, LCREATEKEY
LOCAL IPOS, COPTKEY, COPTION, NERRNUM
IPOS = 0
COPTION = ""
NERRNUM = 0
M.NERRNUM = THIS.OPENKEY(M.CKEYPATH, M.NUSERKEY, M.LCREATEKEY)
IF M.NERRNUM<>0
RETURN M.NERRNUM
ENDIF
NERRNUM = THIS.SETKEYVALUE(M.COPTNAME, M.COPTVAL)
THIS.CLOSEKEY()
RETURN M.NERRNUM
ENDFUNC
**
FUNCTION getregkey
LPARAMETERS COPTNAME, COPTVAL, CKEYPATH, NUSERKEY
LOCAL IPOS, COPTION, NERRNUM
IPOS = 0
COPTION = ""
NERRNUM = 0
M.NERRNUM = THIS.OPENKEY(M.CKEYPATH, M.NUSERKEY)
IF M.NERRNUM<>0
RETURN M.NERRNUM
ENDIF
NERRNUM = THIS.GETKEYVALUE(COPTNAME, @COPTVAL)
THIS.CLOSEKEY()
RETURN M.NERRNUM
ENDFUNC
**
FUNCTION getkeyvalue
LPARAMETERS CVALUENAME, CKEYVALUE
LOCAL LPDWRESERVED, LPDWTYPE, LPBDATA, LPCBDATA, NERRCODE
STORE 0 TO LPDWRESERVED, LPDWTYPE
STORE SPACE(256) TO LPBDATA
STORE LEN(M.LPBDATA) TO M.LPCBDATA
DO CASE
CASE TYPE("THIS.nCurrentKey")<>'N' .OR. THIS.NCURRENTKEY=0
RETURN -105
CASE TYPE("m.cValueName")<>"C"
RETURN -103
ENDCASE
M.NERRCODE = REGQUERYVALUEEX(THIS.NCURRENTKEY, M.CVALUENAME, M.LPDWRESERVED, @LPDWTYPE, @LPBDATA, @LPCBDATA)
IF M.NERRCODE<>0
RETURN M.NERRCODE
ENDIF
IF M.LPDWTYPE<>1 .AND. M.LPDWTYPE<>2
RETURN -106
ENDIF
M.CKEYVALUE = LEFT(M.LPBDATA, M.LPCBDATA-1)
RETURN 0
ENDFUNC
**
FUNCTION setkeyvalue
LPARAMETERS CVALUENAME, CVALUE
LOCAL NVALUESIZE, NERRCODE
DO CASE
CASE TYPE("THIS.nCurrentKey")<>'N' .OR. THIS.NCURRENTKEY=0
RETURN -105
CASE TYPE("m.cValueName")<>"C" .OR. TYPE("m.cValue")<>"C"
RETURN -103
ENDCASE
CVALUE = M.CVALUE+CHR(0)
NVALUESIZE = LEN(M.CVALUE)
M.NERRCODE = REGSETVALUEEX(THIS.NCURRENTKEY, M.CVALUENAME, 0, 1, M.CVALUE, M.NVALUESIZE)
IF M.NERRCODE<>0
RETURN M.NERRCODE
ENDIF
RETURN 0
ENDFUNC
**
FUNCTION deletekey
LPARAMETERS NUSERKEY, CKEYPATH
LOCAL NERRNUM
NERRNUM = 0
M.NERRNUM = REGDELETEKEY(M.NUSERKEY, M.CKEYPATH)
RETURN M.NERRNUM
ENDFUNC
**
FUNCTION enumoptions
LPARAMETERS AREGOPTS, COPTPATH, NUSERKEY, LENUMKEYS
LOCAL IPOS, COPTION, NERRNUM
IPOS = 0
COPTION = ""
NERRNUM = 0
IF PCOUNT()<4 .OR. TYPE("m.lEnumKeys")<>"L"
LENUMKEYS = .F.
ENDIF
M.NERRNUM = THIS.OPENKEY(M.COPTPATH, M.NUSERKEY)
IF M.NERRNUM<>0
RETURN M.NERRNUM
ENDIF
IF M.LENUMKEYS
NERRNUM = THIS.ENUMKEYS(@AREGOPTS)
ELSE
NERRNUM = THIS.ENUMKEYVALUES(@AREGOPTS)
ENDIF
THIS.CLOSEKEY()
RETURN M.NERRNUM
ENDFUNC
**
FUNCTION iskey
LPARAMETERS CKEYNAME, NREGKEY
LOCAL NERRNUM
NERRNUM = THIS.OPENKEY(M.CKEYNAME, M.NREGKEY)
IF M.NERRNUM=0
THIS.CLOSEKEY()
ENDIF
RETURN M.NERRNUM=0
ENDFUNC
**
FUNCTION enumkeys
LPARAMETERS AKEYNAMES
LOCAL NKEYENTRY, CNEWKEY, CBUF, NBUFLEN, CRETTIME, NKEYSIZE, NERRCODE
NKEYENTRY = 0
DIMENSION AKEYNAMES[1]
DO WHILE .T.
NKEYSIZE = 0
CNEWKEY = SPACE(100)
NKEYSIZE = LEN(M.CNEWKEY)
CBUF = SPACE(100)
NBUFLEN = LEN(M.CBUF)
CRETTIME = SPACE(100)
M.NERRCODE = REGENUMKEYEX(THIS.NCURRENTKEY, M.NKEYENTRY, @CNEWKEY, @NKEYSIZE, 0, @CBUF, @NBUFLEN, @CRETTIME)
DO CASE
CASE M.NERRCODE=259
EXIT
CASE M.NERRCODE<>0
EXIT
ENDCASE
CNEWKEY = ALLTRIM(M.CNEWKEY)
CNEWKEY = LEFT(M.CNEWKEY, LEN(M.CNEWKEY)-1)
IF  .NOT. EMPTY(AKEYNAMES(1))
DIMENSION AKEYNAMES[ALEN(AKEYNAMES)+1]
ENDIF
AKEYNAMES[ALEN(AKEYNAMES)] = M.CNEWKEY
NKEYENTRY = M.NKEYENTRY+1
ENDDO
IF M.NERRCODE=259 .AND. M.NKEYENTRY<>0
M.NERRCODE = 0
ENDIF
RETURN M.NERRCODE
ENDFUNC
**
FUNCTION enumkeyvalues
LPARAMETERS AKEYVALUES
LOCAL LPSZVALUE, LPCCHVALUE, LPDWRESERVED
LOCAL LPDWTYPE, LPBDATA, LPCBDATA
LOCAL NERRCODE, NKEYENTRY
STORE 0 TO NKEYENTRY
IF TYPE("THIS.nCurrentKey")<>'N' .OR. THIS.NCURRENTKEY=0
RETURN -105
ENDIF
IF THIS.NCURRENTOS=1
RETURN -107
ENDIF
DO WHILE .T.
STORE 0 TO LPDWRESERVED, LPDWTYPE, NERRCODE
STORE SPACE(256) TO LPBDATA, LPSZVALUE
STORE LEN(LPBDATA) TO M.LPCCHVALUE
STORE LEN(LPSZVALUE) TO M.LPCBDATA
NERRCODE = REGENUMVALUE(THIS.NCURRENTKEY, M.NKEYENTRY, @LPSZVALUE, @LPCCHVALUE, M.LPDWRESERVED, @LPDWTYPE, @LPBDATA, @LPCBDATA)
DO CASE
CASE M.NERRCODE=259
EXIT
CASE M.NERRCODE<>0
EXIT
ENDCASE
NKEYENTRY = M.NKEYENTRY+1
DIMENSION AKEYVALUES[M.NKEYENTRY, 2]
AKEYVALUES[M.NKEYENTRY, 1] = LEFT(M.LPSZVALUE, M.LPCCHVALUE)
DO CASE
CASE LPDWTYPE=1
AKEYVALUES[M.NKEYENTRY, 2] = LEFT(M.LPBDATA, M.LPCBDATA-1)
CASE LPDWTYPE=2 .AND.  .NOT. THIS.LDISALLOWEXPANDED
AKEYVALUES[M.NKEYENTRY, 2] = LEFT(M.LPBDATA, M.LPCBDATA-1)
CASE LPDWTYPE=3
AKEYVALUES[M.NKEYENTRY, 2] = "*Binario*"
CASE LPDWTYPE=4
AKEYVALUES[M.NKEYENTRY, 2] = LEFT(M.LPBDATA, M.LPCBDATA-1)
OTHERWISE
AKEYVALUES[M.NKEYENTRY, 2] = "*Tipo desconocido*"
ENDCASE
ENDDO
IF M.NERRCODE=259 .AND. M.NKEYENTRY<>0
M.NERRCODE = 0
ENDIF
RETURN M.NERRCODE
ENDFUNC
**
FUNCTION deletekeyvalue
LPARAMETERS COPTNAME, CKEYPATH, NUSERKEY
LOCAL COPTION, NERRNUM
COPTION = COPTNAME
NERRNUM = 0
M.NERRNUM = THIS.OPENKEY(M.CKEYPATH, M.NUSERKEY)
IF M.NERRNUM<>0
RETURN M.NERRNUM
ENDIF
M.NERRNUM = REGDELETEVALUE(THIS.NCURRENTKEY, M.COPTION)
THIS.CLOSEKEY()
RETURN M.NERRNUM
ENDFUNC
**
FUNCTION Init
LOCAL LATMPDLLS, LNDLLS
DIMENSION LATMPDLLS[1]
THIS.NUSERKEY = -2147483647
THIS.CVFPOPTPATH = "Software\Microsoft\VisualFoxPro\"+_VFP.VERSION+"\Options"
DO CASE
CASE _DOS .OR. _UNIX .OR. _MAC
RETURN .F.
CASE ATC("Windows 3", OS(1))<>0
THIS.NCURRENTOS = 1
CASE ATC("Windows NT", OS(1))<>0
THIS.NCURRENTOS = 2
THIS.CREGDLLFILE = "ADVAPI32.DLL"
THIS.CINIDLLFILE = "KERNEL32.DLL"
THIS.CODBCDLLFILE = "ODBC32.DLL"
OTHERWISE
THIS.NCURRENTOS = 3
THIS.CREGDLLFILE = "ADVAPI32.DLL"
THIS.CINIDLLFILE = "KERNEL32.DLL"
THIS.CODBCDLLFILE = "ODBC32.DLL"
ENDCASE
LNDLLS = ADLLS(LATMPDLLS)
IF LNDLLS>0
IF ASCAN(LATMPDLLS, "RegOpenKey", -1, -1, -1, 1)<>0
THIS.LHASDLLLOADED = .T.
ENDIF
ENDIF
ENDFUNC
**
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*closekey Closes a registry key.
*deletekey Deletes a registry key.
*deletekeyvalue Deletes value from registry key.
*enumkeys Enumerates through a registry key.
*enumkeyvalues Enumerates through values of a registry key
*enumoptions Enumerates through all entries for a key and populates array.
*getkeyvalue Obtains a value from a registry key.
*getregkey Gets a registry key setting.
*iskey Checks to see if a key exists.
*loadregfuncs Loads funtions needed for Registry.
*openkey Opens a registry key.
*setkeyvalue Sets a key value.
*setregkey Sets a registry key setting.
capppathkey Application path registry key.
cinidllfile DLL file for INI functions.
codbcdllfile DLL file for ODBC functions.
cregdllfile DLL file for registry functions.
cvfpoptpath Registry path to VFP options settings.
lcreatekey Whether to create key if one does not already exist.
ldisallowexpanded
lhaderror Whether an error occurred.
lhasdllloaded
lloadeddlls Whether registry key functions loaded.
lloadedinis Whether INI functions loaded.
lloadedodbcs Whether ODBC functions loaded.
ncurrentkey Current registry key.
ncurrentos Current operating system code.
nuserkey User registry key.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\registry.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] registry
[EOF]
