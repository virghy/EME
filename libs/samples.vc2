*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="samples.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cbofontname AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	FontBold = .F.
	Height = 25
	Name = "fontbox"
	Style = 2
	Width = 217
	
	PROCEDURE Init
		DIMENSION x[1]
		=afont(x)
		FOR i = 1 TO ALEN(x)
			THIS.AddItem(x[i])
		ENDFOR
	ENDPROC

ENDDEFINE

DEFINE CLASS cbofontsize AS combobox 		&& displays the font sizes available for a particular font
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: filllist
		*p: nlargestfont		&& for scalable fonts, specifies the largest allowable fontsize
		*p: nsmallestfont		&& for scalable fonts, smallest allowable fontsize
	*</DefinedPropArrayMethod>

	FontBold = .F.
	Height = 25
	Name = "cbofontsize"
	nlargestfont = 24		&& for scalable fonts, specifies the largest allowable fontsize
	nsmallestfont = 6		&& for scalable fonts, smallest allowable fontsize
	Style = 2
	ToolTipText = "FontSize"
	Width = 44
	
	PROCEDURE filllist
		LPARAMETERS cFontName
		
		THIS.Clear
		
		DIMENSION aSizes[1]
		=AFONT(aSizes, cFontname)
		IF aSizes[1] = -1  && The font is scalable
			lScalable = .T.
			nLen = THIS.nLargestFont
			nStart = THIS.nSmallestFont
		ELSE
			nLen = ALEN(aSizes)
			nStart = 1
			lScalable = .F.
		ENDIF
		
		IF lScalable
			FOR i = nStart TO nLen
				THIS.AddItem(ALLTRIM(STR(i)))
			ENDFOR
		ELSE
			FOR i = nStart TO nLen
				THIS.AddItem(ALLTRIM(STR(aSizes[i])))
			ENDFOR
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS clock AS container 		&& day, date, and time control
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="F:\VFP\SAMPLES\CONTROLS\clock.bmp" ClassIcon="F:\VFP\SAMPLES\CONTROLS\clock.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtTime" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Timer1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: timeformat
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 28
	Name = "clock"
	timeformat = 0
	Width = 251

	ADD OBJECT 'Timer1' AS timer WITH ;
		Height = 12, ;
		Interval = 1000, ;
		Left = 8, ;
		Name = "Timer1", ;
		Top = 3, ;
		Width = 14
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'txtDate' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,0, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		DisabledBackColor = 255,255,255, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 3, ;
		Name = "txtDate", ;
		Top = 5, ;
		Value = (CDOW(date())+" "+CMONTH(date())+" "+  ALLT(STR(DAY(date())))+", "+ALLT(STR(YEAR(date())))), ;
		Width = 179
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtTime' AS textbox WITH ;
		Alignment = 2, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		DisabledBackColor = 255,255,255, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 184, ;
		Name = "txtTime", ;
		Top = 5, ;
		Value = (IIF(THIS.PARENT.TimeFormat = 0, IIF(VAL(SUBSTR(time(),1,2))>12, 	ALLT(STR((VAL(SUBSTR(time(),1,2))-12)))+SUBSTR(time(),3,6), 		time()),time())), ;
		Width = 57
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE DblClick
		THIS.TimeFormat = ABS(THIS.TimeFormat - 1)
		
	ENDPROC

	PROCEDURE Timer1.Timer
		#DEFINE LONGDATE_LOC CDOW(DATE())+" "+CMONTH(DATE())+" "+ ;
					ALLTRIM(STR(DAY(DATE())))+", "+ALLTRIM(STR(YEAR(DATE())))
		
		IF This.Parent.TimeFormat = 0
			This.Parent.txtTime.Value = IIF(VAL(SUBSTR(TIME(),1,2))>12, ;
				ALLTRIM(STR((VAL(SUBSTR(TIME(),1,2))-12)))+SUBSTR(TIME(),3,6),TIME())
		ELSE
			This.Parent.txtTime.Value = TIME()
		ENDIF
		
		THIS.Parent.txtDate.Value = LONGDATE_LOC
		
	ENDPROC

ENDDEFINE

DEFINE CLASS datachecker AS custom 		&& manages conflicts
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="checker.bmp" ClassIcon="checker.bmp" />

	*<DefinedPropArrayMethod>
		*m: checkconflicts		&& Notifies a user if someone else has changed the data in the table after he or she began editing a record.
		*m: handlerecord		&& compares the current value, old value, and original value of each field, displaying a messagebox if a change or conflict is detected.
		*m: string		&& returns type 'c' equivalent of passed value
		*m: verifychanges		&& Prompts a user to save all changes made to a table or record.
		*m: verifyeachchange		&& Prompts a user to confirm each change he or she made.
	*</DefinedPropArrayMethod>

	Height = 15
	Name = "datachecker"
	Width = 23
	
	PROCEDURE checkconflicts		&& Notifies a user if someone else has changed the data in the table after he or she began editing a record.
		*---------------------------------------------------------------*
		*  Checks to see whether another user has changed the value 
		*  stored in a table.  If so, calls HandleRecord to display
		*  the new value and allow the user to decide what to do.
		*
		*  RETURNS NUMERIC VALUES:
		*    0 -- No Changes Made to the Current Values
		*    1 -- Successfully Made User-Specified Changes
		*	 2 -- Unable to Make Write One or More User-Specifed Changes to Table
		*---------------------------------------------------------------*
		
		#define NOBUFF1_LOC 'Data buffering is not enabled.'
		LOCAL lnSuccess, llnRec
		m.lnSuccess = 0  
		
		DO CASE
			CASE INLIST(CURSORGETPROP('Buffering'), 2,3) && Row Buffering
				IF '2' $ GETFLDSTATE(-1)				 && Data has changed
					m.lnSuccess = THIS.HandleRecord(0)
				ENDIF	
			CASE INLIST(CURSORGETPROP('Buffering'), 4,5) && Table Buffering
				m.llnRec = GETNEXTMODIFIED(0)
				DO WHILE m.llnRec > 0
					GO m.llnRec
					m.lnSuccess = IIF(m.lnSuccess != 2, THIS.HandleRecord(0), 2)
					m.llnRec = GETNEXTMODIFIED(m.llnRec)	
				ENDDO
			OTHERWISE									 && no buffering
				WAIT WINDOW NOBUFF_LOC NOWAIT
		ENDCASE
		RETURN m.lnSuccess
	ENDPROC

	PROCEDURE handlerecord		&& compares the current value, old value, and original value of each field, displaying a messagebox if a change or conflict is detected.
		*---------------------------------------------------------------*
		*  This method is called from the CheckConflicts method and the 
		*  VerifyEachChange method.  It loops through each field in the
		*  current record and compares the current value with the value
		*  stored in the table. If a value of 1 is passed to this method,
		*  the method also compares the current value with the value in
		*  the field before user made any edits.
		*
		*  RETURNS NUMERIC VALUES:
		*    0 -- No Change Made to the Current Value
		*    1 -- Successfully Made User-Specified Change
		*	 2 -- Unable to Make User-Specifed Change
		*---------------------------------------------------------------*
		
		LPARAMETERS lnScope
		
		*--Valid values for lnScope:
		* 	0 - Only manage conflicts   && default
		*   1 - Also prompt for changed values
		
		* Verify parameter
		IF TYPE("m.lnScope") != "N"
			m.lnScope = 0 
		ENDIF
		IF !BETWEEN(m.lnScope, 0, 1)
			#define WINDMSG_LOC "Invalid value passed to conflictmanager.handlerecord"
			WAIT WINDOW WINDMSG_LOC
		ENDIF
		
		* Declare constants & variables
		#define CR_LOC CHR(13)
		#define SAVE_LOC "Do you want to overwrite the current value with your change?" + CR_LOC + "(Choose 'Cancel' to restore the original value.)"
		#define CONFLICT_LOC "Data Conflict"
		#define VERIFY_LOC "Verify Changes"
		#define ORG_LOC "Original Value: "
		#define CUR_LOC "Current Value: " 
		#define CHG_LOC "Your change: "
		#define MEMO_LOC " is a Memo field."
		#define FIELD_LOC "Field: "
		#define RECORD_LOC "Record Number: "
		#define VALCHG1_LOC "A value has been changed by another user."
		#define VALCHG2_LOC "A value has been changed."
		
		LOCAL lnChoice, lnField, lcField, luOldVal, luCurVal, luField, llMadeChange, llSuccess
		m.llMadeChange = .F.
		m.llSuccess = .T.
		
		* refresh current record in views before checking for conflicts
		IF CURSORGETPROP('SourceType') != 3 && not a local table
			=REFRESH()
		ENDIF
		
		* Check each field in the record for conflict or value change
		FOR m.lnField = 1 to FCOUNT()
			m.lnChoice = 0
			
			m.lcField = FIELD(m.lnField)
			IF TYPE(m.lcField) = "G"
				LOOP && Can't check general fields
			ENDIF
			m.luOldVal = OLDVAL(m.lcField)
			m.luCurVal = CURVAL(m.lcField)
			
			DO CASE
				* -----< check for conflicts only >--------
				CASE m.lnScope = 0
					IF m.luOldVal != m.luCurVal
						m.llMadeChange = .T.  
						m.lnChoice = MESSAGEBOX(VALCHG1_LOC + CR_LOC + FIELD_LOC + lcField + CR_LOC + ;
						RECORD_LOC + ALLTRIM(STR(RECNO())) + ;
							IIF(TYPE("m.lcField") != "M", CR_LOC + CR_LOC + ORG_LOC + THIS.String(m.luOldVal) + ;
							CR_LOC + CUR_LOC + THIS.String(m.luCurVal) + ;
							CR_LOC + CHG_LOC + THIS.String(EVAL(m.lcField)), CR_LOC + CR_LOC + m.lcField + MEMO_LOC) + ;
							CR_LOC + CR_LOC + SAVE_LOC, + 3+48+0, CONFLICT_LOC)					
					ENDIF
				* -----< check for conflicts and verify all changes >--------
				CASE m.lnScope = 1 && Verify all changes
					m.luField = EVAL(m.lcField)
					IF m.luOldVal != m.luField OR m.luCurVal != m.luField
						m.llMadeChange = .T.  
						m.lnChoice = MESSAGEBOX(VALCHG2_LOC + CR_LOC + FIELD_LOC + m.lcField + CR_LOC + ;
						RECORD_LOC + ALLTRIM(STR(RECNO())) + ;
							IIF(TYPE("m.lcField") != "M", CR_LOC + CR_LOC + ORG_LOC + THIS.String(m.luOldVal) + ;
							CR_LOC + CUR_LOC + THIS.String(m.luCurVal) + ;
							CR_LOC + CHG_LOC + THIS.String(EVAL(m.lcField)), CR_LOC  + CR_LOC + m.lcField + MEMO_LOC) + ;
						CR_LOC + CR_LOC + SAVE_LOC, + 3+48+0, VERIFY_LOC)
					ENDIF
			ENDCASE
			DO CASE
			CASE m.lnChoice = 7 && No, don't save changes
				REPLACE (m.lcField) WITH m.luCurVal
			CASE m.lnChoice = 2 && Cancel, restore original value
				REPLACE (m.lcField) WITH m.luOldVal
			ENDCASE
		ENDFOR
		IF m.llMadeChange
			m.llSuccess = TABLEUPDATE(.F., .T.)
			RETURN IIF(m.llSuccess, 1, 2)
		ELSE
			RETURN 0 
		ENDIF
		
	ENDPROC

	PROCEDURE string		&& returns type 'c' equivalent of passed value
		*---------------------------------------------------------------*
		*  This method is called from the HandleRecord method.  It 
		*  returns the character equivalent of the value passed in as a
		*  parameter.  If a memo field is passed in, a notice to this
		*  effect is returned rather than the value in the memo field so
		*  that potentially large amounts of text aren't displayed in the 
		*  messagebox.
		*---------------------------------------------------------------*
		
		LPARAMETERS luValue
		
		m.uType = TYPE('m.luValue')
		DO CASE
			CASE m.uType = 'C'
				RETURN ALLTRIM(m.luValue)
			CASE INLIST(m.uType, 'N', 'Y')
				RETURN ALLTRIM(STR(m.luValue))
			CASE m.uType = 'D'
				RETURN DTOC(m.luValue)
			CASE m.uType = 'T'
				RETURN TTOC('m.luValue')
			CASE m.uType = 'L'
				RETURN IIF(m.luValue, '.T.', '.F.')
			CASE uType = 'M'
				RETURN 'Memo field'
		ENDCASE
	ENDPROC

	PROCEDURE verifychanges		&& Prompts a user to save all changes made to a table or record.
		*---------------------------------------------------------------*
		*  If any changes have been made to the table or record, prompt the
		*  user to save the changes.  If the user says 'yes,' all changes
		*  are saved.  Any changes made to the data by other users after
		*  this user made the change and before the change was committed
		*  will be lost.
		*
		*  RETURNS NUMERIC VALUES:
		*    0 -- No Changes Made to the Current Values
		*    1 -- Successfully Made All User Changes
		*	 2 -- Unable to Write One or More User-Specifed Changes to Table
		*---------------------------------------------------------------*
		
		* Declare constants & variables
		#define SAVECHG_LOC 'Do you want to save your changes?'
		#define SAVECHG2_LOC 'Save Changes'
		#define NOBUFF_LOC2 'Data buffering is not enabled.'
		
		LOCAL lnChoice, llMadeChange, lnSuccess
		m.llMadeChange = .F.
		m.lnSuccess = 0
		
		* If the user has changed anything, prompt to save or discard changes
		DO CASE
			CASE INLIST(CURSORGETPROP('Buffering'), 2,3) && Row Buffering
				IF '2' $ GETFLDSTATE(-1)
					m.llMadeChange = .T.
				ENDIF
			CASE INLIST(CURSORGETPROP('Buffering'), 4,5) && Table Buffering
				IF GETNEXTMODIFIED(0) > 0
					m.llMadeChange = .T.
				ENDIF
			OTHERWISE
				WAIT WINDOW NOBUFF_LOC NOWAIT
		ENDCASE
		
		IF m.llMadeChange
			m.lnChoice = MESSAGEBOX(SAVECHG_LOC, 4+32, SAVECHG2_LOC)
			IF m.lnChoice = 6 && Yes
				m.lnSuccess = IIF(TABLEUPDATE(.T.,.T.), 1, 2)
			ELSE
				=TABLEREVERT(.T.)
			ENDIF
		ENDIF	
		RETURN m.lnSuccess
	ENDPROC

	PROCEDURE verifyeachchange		&& Prompts a user to confirm each change he or she made.
		*--------------------------------------------------------------------
		*  If any changes have been made to the table or record, for each
		*  change, display the old value and the new value, prompting the
		*  user to save or discard the change.  Conflict management is also
		*  included in the HandleRecord method.
		*
		*  RETURNS NUMERIC VALUES:
		*    0 -- No Changes Made to the Current Values
		*    1 -- Successfully Made User-Specified Changes
		*	 2 -- Unable to Write One or More User-Specifed Changes to Table
		*---------------------------------------------------------------*
		
		#define NOBUFF_LOC3 'Data buffering is not enabled.'
		LOCAL lnSuccess, lnRec
		m.lnSuccess = 0
		
		DO CASE
			CASE INLIST(CURSORGETPROP('Buffering'), 2,3) && Row Buffering
				IF '2' $ GETFLDSTATE(-1)				 && Data has changed
					m.lnSuccess = THIS.HandleRecord(1)
				ENDIF	
			CASE INLIST(CURSORGETPROP('Buffering'), 4,5) && Table Buffering
				m.lnRec = GETNEXTMODIFIED(0)
				DO WHILE m.lnRec > 0
					GO m.lnRec
					m.lnSuccess = IIF(m.lnSuccess != 2, THIS.HandleRecord(1), 2)
					m.lnRec = GETNEXTMODIFIED(m.lnRec)	
				ENDDO
			OTHERWISE									 && No Buffering
				WAIT WINDOW NOBUFF_LOC NOWAIT
		ENDCASE
		RETURN m.lnSuccess
	ENDPROC

ENDDEFINE

DEFINE CLASS distinct_values_combo AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	FontName = "MS Sans Serif"
	FontSize = 8
	Height = 23
	Name = "distinct_values_combo"
	Width = 106
	
	PROCEDURE Destroy
		cCursor = "c" + THIS.name
		IF USED(cCursor) THEN
			USE IN &cCursor
		ENDIF
	ENDPROC

	PROCEDURE Init
		#DEFINE NO_TABLE_LOC "The table alias must be specified in the controlSource property, in the format 'alias.column'."
		
		IF !EMPTY(THIS.controlSource) THEN
			IF NOT "." $ THIS.controlSource THEN
				=MESSAGEBOX(NO_TABLE_LOC)
			ELSE
				cAlias = LEFTC(THIS.controlSource,(ATC(".",THIS.controlSource)-1))
				cColumn = RIGHTC(THIS.controlSource,(LENC(THIS.controlSource)-ATC(".",THIS.controlSource)))
				THIS.rowSourceType = 3
				cSQL = "SELECT DISTINCT " + cColumn + " FROM " + cAlias + ;
				  " INTO CURSOR c" + THIS.name
				THIS.rowSource = cSQL
			ENDIF
		ENDIF
			
	ENDPROC

ENDDEFINE

DEFINE CLASS frmnotitle AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	AlwaysOnTop = .T.
	BorderStyle = 1
	Caption = ""
	Closable = .F.
	ControlBox = .F.
	DoCreate = .T.
	Height = 150
	Left = 0
	MaxButton = .F.
	MinButton = .F.
	Movable = .F.
	Name = "frmnotitle"
	Top = 0
	Width = 300
	ZoomBox = .F.

ENDDEFINE

DEFINE CLASS lookup_combo AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: display_column		&& Specifies the column from lookup_table to display in the drop down list.
		*p: lookup_table		&& Specifies the table to lookup the values to display in the drop down.
		*p: order_column		&& Specifies the column to order the records displayed in the drop down list (optional).
		*p: return_column		&& Specifies the column value to return the value property of the combo box.
	*</DefinedPropArrayMethod>

	display_column = 		&& Specifies the column from lookup_table to display in the drop down list.
	FontName = "MS Sans Serif"
	FontSize = 8
	Height = 23
	lookup_table = 		&& Specifies the table to lookup the values to display in the drop down.
	Name = "lookup_combo"
	order_column = 		&& Specifies the column to order the records displayed in the drop down list (optional).
	return_column = 		&& Specifies the column value to return the value property of the combo box.
	Width = 106
	
	PROCEDURE Destroy
		cAlias = THIS.name
		IF USED(cAlias) THEN
			USE IN &cAlias
		ENDIF
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		#DEFINE INVALID_COLUMN_LOC "An invalid display column or return column has been specified in the 'display_column' or 'return_column' properties (combo box " + THIS.name + ")."
		#DEFINE INVALID_TABLE_LOC "An invalid table has been specified in the 'display_column' or 'lookup_table' property (combo box " + THIS.name + ")."
		#DEFINE INVALID_SORT_LOC "An invalid column has been specified in the 'order_column' property (combo box " + THIS.name + ")."
		
		
		
		DO CASE
			CASE nError = 1806
				=MESSAGEBOX(INVALID_COLUMN_LOC,48)
			CASE nError = 1808
				=MESSAGEBOX(INVALID_SORT_LOC,48)
			CASE nError = 1802
				=MESSAGEBOX(INVALID_TABLE_LOC,48)
			OTHERWISE
				=MESSAGEBOX(MESSAGE(),48)
		ENDCASE
	ENDPROC

	PROCEDURE Init
		#DEFINE NO_LOOKUP_TABLE_LOC "A lookup table must be specified in the 'lookup_table' property (combo box " + THIS.name + ")."
		#DEFINE NO_DISPLAY_COLUMN_LOC "A display column must be specified in the 'display_column' property (combo box " + THIS.name + ")."
		#DEFINE NO_RETURN_COLUMN_LOC "A return column must be specified in the 'return_column' property (combo box " + THIS.name + ")."
		
		lOK = .T.
		DO CASE
			CASE EMPTY(THIS.lookup_table)
				=MESSAGEBOX(NO_LOOKUP_TABLE_LOC,48)
				lOK = .F.
			CASE EMPTY(THIS.display_column)
				=MESSAGEBOX(NO_DISPLAY_COLUMN_LOC,48)
				lOK = .F.
			CASE EMPTY(THIS.return_column)
				=MESSAGEBOX(NO_RETURN_COLUMN_LOC,48)
				lOK = .F.
		ENDCASE
		
		IF lOK THEN
			IF !EMPTY(THIS.order_column)
				nSQL = "SELECT " + THIS.display_column + "," + THIS.return_column + " FROM " + THIS.lookup_table + " ORDER BY " + THIS.order_column + " INTO CURSOR " + THIS.name
			ELSE
				nSQL = "SELECT " + THIS.display_column + "," + THIS.return_column + " FROM " + THIS.lookup_table + " INTO CURSOR " + THIS.name
			ENDIF
			THIS.RowSourceType = 3
			THIS.RowSource = nSQL
			THIS.BoundColumn = 2
		ENDIF
		THIS.Refresh
	ENDPROC

ENDDEFINE

DEFINE CLASS moverlists AS container 		&& mover list boxes
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="moverbox.bmp" ClassIcon="moverbox.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstSource" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstSelected" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemoveAll" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: selectall		&& selects all items in the listbox passed in as a parameter
		*p: candropicon		&& Cursor when dropping is okay
		*p: dragthreshold		&& number of pixels a user has to move the mouse with the left mouse button down for the drag method to be called.
		*p: mousex		&& stores x coordinate of mouse pointer position
		*p: mousey		&& stores y coordinate of mouse pointer position
		*p: nodropicon
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	candropicon = DRAGMOVE.CUR		&& Cursor when dropping is okay
	dragthreshold = 8		&& number of pixels a user has to move the mouse with the left mouse button down for the drag method to be called.
	Height = 132
	mousex = 0		&& stores x coordinate of mouse pointer position
	mousey = 0		&& stores y coordinate of mouse pointer position
	Name = "moverlists"
	nodropicon = NODROP01.CUR
	Width = 409

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		Caption = ">", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 25, ;
		Left = 186, ;
		Name = "cmdAdd", ;
		TabIndex = 3, ;
		ToolTipText = "Add Selected Items", ;
		Top = 2, ;
		Width = 37
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddAll' AS commandbutton WITH ;
		Caption = ">>", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 25, ;
		Left = 186, ;
		Name = "cmdAddAll", ;
		TabIndex = 4, ;
		ToolTipText = "Add All Items", ;
		Top = 33, ;
		Width = 37
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS commandbutton WITH ;
		Caption = "<", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 25, ;
		Left = 186, ;
		Name = "cmdRemove", ;
		TabIndex = 5, ;
		ToolTipText = "Remove Selected Items", ;
		Top = 71, ;
		Width = 37
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemoveAll' AS commandbutton WITH ;
		Caption = "<<", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 25, ;
		Left = 186, ;
		Name = "cmdRemoveAll", ;
		TabIndex = 6, ;
		ToolTipText = "Remove All Items", ;
		Top = 102, ;
		Width = 37
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'lstSelected' AS listbox WITH ;
		ColumnCount = 0, ;
		ColumnWidths = "", ;
		ControlSource = "", ;
		DragIcon = grid\, ;
		DragMode = 0, ;
		FirstElement = 1, ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 132, ;
		Left = 240, ;
		MoverBars = .T., ;
		MultiSelect = .T., ;
		Name = "lstSelected", ;
		NumberOfElements = 0, ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 2, ;
		Top = 0, ;
		Width = 169
		*< END OBJECT: BaseClass="listbox" />

	ADD OBJECT 'lstSource' AS listbox WITH ;
		ColumnCount = 0, ;
		ColumnWidths = "", ;
		ControlSource = "", ;
		DragIcon = grid\, ;
		DragMode = 0, ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 132, ;
		Left = 0, ;
		MultiSelect = .T., ;
		Name = "lstSource", ;
		NumberOfElements = 0, ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 1, ;
		Top = 0, ;
		Width = 169
		*< END OBJECT: BaseClass="listbox" />
	
	PROCEDURE Init
		This.lstSource.DragIcon = This.CanDropIcon
		This.lstSelected.DragIcon = This.CanDropIcon
		
	ENDPROC

	PROCEDURE selectall		&& selects all items in the listbox passed in as a parameter
		LPARAMETERS oList
		LOCAL lnCnt
		FOR lnCnt = 1 to oList.ListCount
			oList.Selected(lnCnt) = .T.
		ENDFOR
	ENDPROC

	PROCEDURE cmdAdd.Click
		THISFORM.LockScreen = .T.
		* The ListCount value changes whenever the RemoveItem method is called
		nCnt = 1
		DO WHILE nCnt <= THIS.Parent.lstSource.ListCount
			IF THIS.Parent.lstSource.Selected(nCnt)
				THIS.Parent.lstSelected.AddItem(THIS.Parent.lstSource.List(nCnt))
				THIS.Parent.lstSource.RemoveItem(nCnt)
			ELSE
				nCnt = nCnt + 1
			ENDIF
		ENDDO
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE cmdAddAll.Click
		THISFORM.LockScreen = .T.
		FOR i = 1 to THIS.Parent.lstSource.ListCount
			THIS.Parent.lstSelected.AddItem(THIS.Parent.lstSource.List(i))
		ENDFOR
		THIS.Parent.lstSource.Clear
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE cmdRemove.Click
		THISFORM.LockScreen = .T.
		nCnt = 1
		DO WHILE nCnt <= THIS.Parent.lstSelected.ListCount
			IF THIS.Parent.lstSelected.Selected(nCnt)
				THIS.Parent.lstSource.AddItem(THIS.Parent.lstSelected.List(nCnt))
				THIS.Parent.lstSelected.RemoveItem(nCnt)
			ELSE
				nCnt = nCnt + 1
			ENDIF
		ENDDO
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE cmdRemoveAll.Click
		THISFORM.LockScreen = .T.
		FOR i = 1 to THIS.Parent.lstSelected.ListCount
			THIS.Parent.lstSource.AddItem(THIS.Parent.lstSelected.List(i))
		ENDFOR
		THIS.Parent.lstSelected.Clear
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE lstSelected.DblClick
		THIS.Parent.lstSource.AddItem(This.List(This.ListIndex))
		This.RemoveItem(This.ListIndex)
		
	ENDPROC

	PROCEDURE lstSelected.DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		IF oSource.Name != THIS.Name
			THIS.Parent.cmdAdd.Click
		ENDIF
		
	ENDPROC

	PROCEDURE lstSelected.DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		DO CASE
			CASE nState = 0 && Enter
				oSource.DragIcon = THIS.Parent.CanDropIcon
			CASE nState = 1 && Leave
				oSource.DragIcon = THIS.Parent.NoDropIcon
		ENDCASE
		
	ENDPROC

	PROCEDURE lstSelected.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		IF nKeyCode = 63 AND nShiftAltCtrl = 1
			THIS.Parent.SelectAll(THIS)
		ENDIF
	ENDPROC

	PROCEDURE lstSelected.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		THIS.Parent.MouseX = nXCoord
		THIS.Parent.MouseY = nYCoord
		
	ENDPROC

	PROCEDURE lstSelected.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF nButton = 1 && Left Mouse
			IF ABS(nXCoord - THIS.Parent.MouseX) > THIS.Parent.DragThreshold OR ;
					ABS(nYCoord - THIS.Parent.MouseY) > THIS.Parent.DragThreshold
				THIS.Drag
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lstSource.DblClick
		THIS.Parent.lstSelected.AddItem(This.List(This.ListIndex))
		This.RemoveItem(This.ListIndex)
		
	ENDPROC

	PROCEDURE lstSource.DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		IF oSource.Name != THIS.Name
			THIS.Parent.cmdRemove.Click
		ENDIF
		
	ENDPROC

	PROCEDURE lstSource.DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		DO CASE
			CASE nState = 0 && Enter
				oSource.DragIcon = THIS.Parent.CanDropIcon
			CASE nState = 1 && Leave
				oSource.DragIcon = THIS.Parent.NoDropIcon
		ENDCASE
		
		
	ENDPROC

	PROCEDURE lstSource.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		IF nKeyCode = 63 AND nShiftAltCtrl = 1
			THIS.Parent.SelectAll(THIS)
		ENDIF
	ENDPROC

	PROCEDURE lstSource.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		THIS.Parent.MouseX = nXCoord
		THIS.Parent.MouseY = nYCoord
		
	ENDPROC

	PROCEDURE lstSource.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF nButton = 1 && Left Mouse
			IF ABS(nXCoord - THIS.Parent.MouseX) > THIS.Parent.DragThreshold OR ;
					ABS(nYCoord - THIS.Parent.MouseY) > THIS.Parent.DragThreshold
				THIS.Drag
			ENDIF
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS print_report AS form 		&& Provides a form that allows users to choose the output of a report.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="opgReportOutput" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblReportOutput" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFileName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSaveAs" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oleCommDlog" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: creport		&& Specifies the report to print from this form.
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	BorderStyle = 2
	Caption = "Print Report"
	creport = 		&& Specifies the report to print from this form.
	Desktop = .T.
	DoCreate = .T.
	Height = 136
	MaxButton = .F.
	MinButton = .F.
	Name = "print_report"
	Width = 342
	WindowType = 1

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 261, ;
		Name = "cmdCancel", ;
		Top = 42, ;
		Width = 72
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS commandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 261, ;
		Name = "cmdOK", ;
		Top = 14, ;
		Width = 72
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSaveAs' AS commandbutton WITH ;
		Caption = "...", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 228, ;
		Name = "cmdSaveAs", ;
		Top = 83, ;
		Width = 19
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Label2' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "File Name:", ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 37, ;
		Name = "Label2", ;
		Top = 85, ;
		Width = 52
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblReportOutput' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = " Report Output ", ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 20, ;
		Name = "lblReportOutput", ;
		Top = 7, ;
		Width = 75
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'oleCommDlog' AS olecontrol WITH ;
		Height = 100, ;
		Left = 278, ;
		Name = "oleCommDlog", ;
		Top = 88, ;
		Width = 100
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\system\comdlg32.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIC8ecDRXrsBAwAAAIABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZQAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAE0AAAAAAAAABAAAAAIAAAD+////BQAAAP7////+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+FPAT58vYaEKPJCAArL0n7AAABAE8DAABPAwAAAAAAAAAAAAAAAAAAAAUqLnR4dBJUZXh0ICgqLnR4dCl8Ki50XAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyOEM0QzgyMC00MDFBLTEwMUItQTNDOS0wODAwMkIyRjQ5RkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACACQAAAEZpbGVOYW1lAA4AAABIAAAAAAUAAAAqLnR4dAcAAABGaWx0ZXIAGwAAAEgAAAAAEgAAAFRleHQgeHQAAAAAAAAAAAAAAABBAAAAAAAAAAAAAAAAAAAAAAAEAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgqLnR4dCl8Ki50eHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAACY7YIA" />

	ADD OBJECT 'opgReportOutput' AS optiongroup WITH ;
		BackStyle = 0, ;
		ButtonCount = 3, ;
		Height = 110, ;
		Left = 10, ;
		Name = "opgReportOutput", ;
		Top = 14, ;
		Value = 1, ;
		Width = 242, ;
		Option1.AutoSize = .T., ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "Print Preview", ;
		Option1.FontBold = .F., ;
		Option1.FontName = "MS Sans Serif", ;
		Option1.FontSize = 8, ;
		Option1.Height = 15, ;
		Option1.Left = 11, ;
		Option1.Name = "optPreview", ;
		Option1.Top = 12, ;
		Option1.Value = 1, ;
		Option1.Width = 80, ;
		Option2.AutoSize = .T., ;
		Option2.BackStyle = 0, ;
		Option2.Caption = "Printer", ;
		Option2.FontBold = .F., ;
		Option2.FontName = "MS Sans Serif", ;
		Option2.FontSize = 8, ;
		Option2.Height = 15, ;
		Option2.Left = 11, ;
		Option2.Name = "optPrinter", ;
		Option2.Top = 30, ;
		Option2.Value = 0, ;
		Option2.Width = 48, ;
		Option3.AutoSize = .T., ;
		Option3.BackStyle = 0, ;
		Option3.Caption = "File", ;
		Option3.FontBold = .F., ;
		Option3.FontName = "MS Sans Serif", ;
		Option3.FontSize = 8, ;
		Option3.Height = 15, ;
		Option3.Left = 11, ;
		Option3.Name = "optFile", ;
		Option3.Top = 48, ;
		Option3.Value = 0, ;
		Option3.Width = 34
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'txtFileName' AS textbox WITH ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 95, ;
		Name = "txtFileName", ;
		Top = 81, ;
		Width = 128
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Init
		#DEFINE REPORT_NOT_FOUND_LOC "The report file '" + THISFORM.cReport + ;
				"' does not exist." + CHR(13) + CHR(13) + ;
				"You must specify a valid report file to print in the cReport property of the form or passed in as a parameter."
		#DEFINE NO_REPORT_LOC "The report to print must either be specified in the cReport property of the form or passed in as a parameter."
		
		
		LPARAMETERS cRepName
		
		*!* If no parameters are passed in, the variables are automatically
		*!* set to a logical .F. value.
		IF TYPE("cRepName") = "C" THEN
			*!* If a parameter is passed in, assume it is the report
			*!* name and set the cReport property of the form to it.
			THISFORM.cReport = cRepName
		ENDIF
		
		IF EMPTY(THISFORM.cReport) THEN
			MESSAGEBOX(NO_REPORT_LOC)
			RETURN .F.
		ENDIF
		
		IF !FILE(THISFORM.cReport) THEN
			MESSAGEBOX(REPORT_NOT_FOUND_LOC)
			RETURN .F.
		ENDIF
		
		
				
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		THISFORM.Release
	ENDPROC

	PROCEDURE cmdOK.Click
		#DEFINE NO_REPORT_LOC "The report to print must either be specified in the cReport property of the form or passed in as a parameter."
		#DEFINE NO_FILENAME_LOC "You must enter a file name."
		
		DO CASE
			CASE EMPTY(THISFORM.cReport) 
				=MESSAGEBOX(NO_REPORT_LOC)
				
			CASE THISFORM.opgReportOutput.value = 1
				THISFORM.Release
				REPORT FORM (THISFORM.cReport) PREVIEW NOCONSOLE
				
			CASE THISFORM.opgReportOutput.value = 2
				THISFORM.Release
				REPORT FORM (THISFORM.cReport) TO PRINTER NOCONSOLE
				
			CASE THISFORM.opgReportOutput.value = 3
				IF EMPTY(THISFORM.txtFileName.value) THEN
					=MESSAGEBOX(NO_FILENAME_LOC)
					THISFORM.txtFileName.SetFocus
				ELSE
					THISFORM.Release
					REPORT FORM (THISFORM.cReport) ;
						TO FILE (THISFORM.txtFileName.value) ;
						ASCII NOCONSOLE
				ENDIF
			
		ENDCASE
	ENDPROC

	PROCEDURE cmdSaveAs.Click
		
		* Display file dialog
		thisform.oleCommDlog.ShowSave()
		
		IF thisform.oleCommDlog.FileName <> "*.*"
			THISFORM.txtFileName.Value = thisform.oleCommDlog.FileName
			THISFORM.txtFileName.SetFocus
		ENDIF
	ENDPROC

	PROCEDURE opgReportOutput.optFile.Click
		THISFORM.txtFileName.enabled = .T.
		THISFORM.cmdSaveAs.enabled = .T.
	ENDPROC

	PROCEDURE opgReportOutput.optPreview.Click
		THISFORM.txtFileName.enabled = .F.
		THISFORM.cmdSaveAs.enabled = .F.
	ENDPROC

	PROCEDURE opgReportOutput.optPrinter.Click
		THISFORM.txtFileName.enabled = .F.
		THISFORM.cmdSaveAs.enabled = .F.
	ENDPROC

ENDDEFINE

DEFINE CLASS qbf AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdQBFMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExecuteQBF" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClearFilter" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: parsecondition
		*p: qbf_table		&& Specifies the table to query against.
	*</DefinedPropArrayMethod>

	BorderWidth = 0
	Height = 97
	Name = "qbf"
	qbf_table = 		&& Specifies the table to query against.
	Width = 80

	ADD OBJECT 'cmdClearFilter' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "\<Clear Filter", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 4, ;
		Name = "cmdClearFilter", ;
		TabIndex = 25, ;
		Top = 71, ;
		Width = 72
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExecuteQBF' AS commandbutton WITH ;
		Caption = "\<Query", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 4, ;
		Name = "cmdExecuteQBF", ;
		TabIndex = 24, ;
		Top = 31, ;
		Width = 72
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdQBFMode' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "\<Enter QBF", ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 4, ;
		Name = "cmdQBFMode", ;
		TabIndex = 23, ;
		Top = 3, ;
		Width = 72
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE parsecondition
		LPARAMETERS cCondition, cControlSource
		LOCAL lcRetCondition, lcFieldName
		IF TYPE('cCondition') = 'C'
			cCondition = ALLTRIM(cCondition)
		ENDIF
		
		lcFieldName = SUBSTRC(cControlSource,(RATC(".",cControlSource)+1))
		
		*!* NOTE: If you add a checkbox, radio button, or command group to
		*!* the form, this routine will need to be changed to handle that
		*!* specific datatype.
		
		IF !EMPTY(cCondition) THEN
			*!* If the type is Character or Memo, check to see if the 
			*!* user has entered a complex condition (if so, take that 
			*!* condition literally without any manipulation
			IF TYPE('cCondition')$ "CM" 
				IF ("<"	 	$ cCondition OR ;
					"==" 	$ cCondition OR ;
					"LIKE" 	$ cCondition OR ;
					"<>" 	$ cCondition OR ;
					"!=" 	$ cCondition OR ;
					"#" 	$ cCondition OR ;
					"=" 	$ cCondition OR ;
					">" 	$ cCondition)
				  	lcRetCondition = lcFieldName + cCondition
				ENDIF
			ENDIF
			*!* If a complex condition wasn't found above (lcRetCondition will be empty)
			*!* Then we need to create the WHERE condition ourselves
			IF EMPTY(lcRetCondition)
				*!* The RATC() Functions figure out the column to compare based on the 
				*!* controlSource of the control and any delimiters needed for the 
				*!* datatype are added around the values (not all conditions are
				*!* assumed to be = when we construct them ourselves
				DO CASE
					CASE TYPE(cControlSource) $ "CM"
						lcRetCondition = lcFieldName + " = " + CHR(34) + cCondition + CHR(34)
					CASE TYPE(cControlSource) $ "DT"
						lcRetCondition = lcFieldName + " = {" + DTOC(cCondition) + "}"
					OTHERWISE
						lcRetCondition = lcFieldName + " = " + STR(cCondition)
				ENDCASE	
			ENDIF
		ELSE
			lcRetCondition = ""
		ENDIF
		
		RETURN lcRetCondition
	ENDPROC

	PROCEDURE cmdClearFilter.Click
		
		*!* Clear the filter that was set
		SET FILTER TO
		GO TOP
		THIS.enabled = .F.
		
		THISFORM.Refresh
	ENDPROC

	PROCEDURE cmdExecuteQBF.Click
		LOCAL cFilter
		cFilter = ""
		
		*!* First, we need to walk all the controls on the form and find
		*!* all controls with a controlSource and has a value in the value property.
		
		FOR nCnt = 1 to THISFORM.ControlCount
			IF TYPE('THISFORM.Controls(nCnt).controlSource') <> "U" THEN
				IF !EMPTY(THISFORM.Controls(nCnt).ControlSource) AND ;
				  TYPE('THISFORM.Controls(nCnt).value') <> "U" THEN
				  
				    *!* Now we need to parse the value property into a proper
				    *!* condition using the parseCondition method of the form
					cCondition = THIS.Parent.parseCondition(THISFORM.Controls(nCnt).value,THISFORM.Controls(nCnt).controlSource)
					
					*!* If there is a condition, add it to are overall filter
					IF !EMPTY(cCondition) THEN
						cFilter = cFilter + " AND " + cCondition
					ENDIF
				ENDIF
			ENDIF
		ENDFOR
		
		*!* We need to rollback the transaction to discard the APPEND'ed record
		ROLLBACK
		
		THIS.Enabled = .F.
		THIS.Parent.cmdQBFMode.Enabled = .T.
		
		*!* This removes the " AND " keyword that is not needed for the 
		*!* first condition added to cFilter
		IF !EMPTY(cFilter) THEN
			cFilter = ALLTRIM(SUBSTRC(cFilter,5))
		ENDIF
		
		*!* Now we are ready to apply the filter
		SET FILTER TO &cFilter
		
		THIS.Parent.cmdClearFilter.enabled = .T.
		
		GO TOP
		THISFORM.Refresh
	ENDPROC

	PROCEDURE cmdQBFMode.Click
		
		*!* In order to clear out all the controls with a controlSource,
		*!* we need to start a transaction and append a record (then when
		*!* we are done we'll rollback the transaction so the new record
		*!* doesn't get added to the table
		
		IF !EMPTY(THIS.Parent.QBF_table) THEN
			SELECT (THIS.Parent.QBF_table)
		ENDIF
		
		BEGIN TRANSACTION
		
		APPEND BLANK
		
		THIS.Enabled = .F.
		
		THIS.Parent.cmdExecuteQBF.Enabled = .T.
		THIS.Parent.cmdClearFilter.enabled = .F.
		
		THISFORM.Refresh
	ENDPROC

ENDDEFINE

DEFINE CLASS resizable AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addtoarray
		*m: adjustcontrols		&& call from resize event of a form to adjust the placement and size of contained objects.
		*m: loopthroughcontrols
		*m: reset
		*m: setsize
		*p: initialformheight
		*p: initialformwidth
		*p: initialresize		&& Is this the first time the controls are being adjusted?
		*a: acontrolstats[1,5]
	*</DefinedPropArrayMethod>

	PROTECTED acontrolstats,initialformheight,initialformwidth,initialresize
	Height = 19
	initialformheight = 0
	initialformwidth = 0
	initialresize = .T.		&& Is this the first time the controls are being adjusted?
	Name = "resizable"
	Width = 27
	
	PROTECTED PROCEDURE addtoarray
		LPARAMETERS oControl
		nLen = ALEN(THIS.aControlStats,1)
		THIS.aControlStats[nLen,1] = oControl.Top / THIS.InitialFormHeight
		THIS.aControlStats[nLen,2] = oControl.Left / THIS.InitialFormWidth
		THIS.aControlStats[nLen,3] = oControl.Height / THIS.InitialFormHeight
		THIS.aControlStats[nLen,4] = oControl.Width / THIS.InitialFormWidth
		THIS.aControlStats[nLen,5] = IIF(TYPE("oControl.FontSize") = 'U', 0, oControl.FontSize)
		DIMENSION THIS.aControlStats[nLen+1, 5]
		
	ENDPROC

	PROCEDURE adjustcontrols		&& call from resize event of a form to adjust the placement and size of contained objects.
		IF THIS.InitialResize
			THIS.LoopThroughControls("INITIALIZE_AND_ADJUST")
			THIS.InitialResize = .F.
		ELSE
			THIS.LoopThroughControls("ADJUST")
		ENDIF
	ENDPROC

	PROCEDURE Init
		THIS.InitialFormHeight = THISFORM.Height
		THIS.InitialFormWidth = THISFORM.Width
	ENDPROC

	PROTECTED PROCEDURE loopthroughcontrols
		LPARAMETERS cTask
		* Valid parameters for cTask are 'Initialize_And_Adjust' and 'Adjust'
		cTask = UPPER(cTask)
		
		nOldDecimal = SET("DECIMAL")
		SET DECIMAL TO 4
		
		#define BASE_CLASS "Commandbutton Combobox Checkbox Listbox Form Grid Textbox Label Shape Editbox Olecontrol Pageframe Image Spinner"
		
		nPos = 0
		THISFORM.LockScreen = .T.
		FOR m.i = 1 TO THISFORM.ControlCount
			oControl = THISFORM.Controls[m.i]
			IF oControl.Baseclass$BASE_CLASS
				nPos = nPos + 1
				DO CASE
					CASE cTask = 'INITIALIZE_AND_ADJUST'
						THIS.AddToArray(oControl)
						THIS.SetSize(oControl, nPos)
					CASE cTask = 'ADJUST'
						THIS.SetSize(oControl, nPos)
				ENDCASE
			ENDIF
			*A pageframe can contain only pages
			IF THISFORM.Controls[m.i].Baseclass$"Pageframe"
				*Loop through each page of the pageframe
				FOR m.j = 1 TO THISFORM.Controls[m.i].PageCount
					WITH THISFORM.Controls[m.i].pages[m.j]
						*loop through all the controls on the page
						FOR m.k = 1 TO .ControlCount
							IF .Controls[m.k].Baseclass$BASE_CLASS
								nPos = nPos + 1
								DO CASE
									CASE cTask = 'INITIALIZE_AND_ADJUST'
										THIS.AddToArray(.Controls[m.k])
										THIS.SetSize(.Controls[m.k], nPos)
									CASE cTask = 'ADJUST'
										THIS.SetSize(.Controls[m.k], nPos)
								ENDCASE
							ENDIF
						ENDFOR
					ENDWITH
				ENDFOR
			ENDIF			
		ENDFOR
		
		THISFORM.LockScreen = .F.
		SET DECIMAL TO nOldDecimal
	ENDPROC

	PROCEDURE reset
		THIS.InitialResize = .T.
		DIMENSION THIS.aControlStats[1,5]
	ENDPROC

	PROTECTED PROCEDURE setsize
		LPARAMETERS oControl, nPos
		oControl.Top = THISFORM.Height * THIS.aControlStats[nPos,1]
		oControl.Left = THISFORM.Width * THIS.aControlStats[nPos,2]
		oControl.Width = THISFORM.Width * THIS.aControlStats[nPos,4]
		IF !oControl.Baseclass $ "Textbox Spinner"
			oControl.Height = THISFORM.Height * THIS.aControlStats[nPos,3]
		ENDIF
		
		*IF oControl.Baseclass = "Commandbutton"
		*	IF TXTWIDTH(oControl.caption) > oControl.width 
		*		oControl.FontSize = 8
		*	ELSE
		*		oControl.FontSize = 10
		*	ENDIF
		*ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS rtfcontrols AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cbofontname1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cbofontsize1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBold" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdItalic" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdColor" UniqueID="" Timestamp="" />

	Height = 32
	Name = "rtfcontrols"
	Width = 311

	ADD OBJECT 'Cbofontname1' AS cbofontname WITH ;
		Height = 25, ;
		Left = 4, ;
		Name = "Cbofontname1", ;
		Top = 4, ;
		Width = 157
		*< END OBJECT: ClassLib="samples.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cbofontsize1' AS cbofontsize WITH ;
		Left = 172, ;
		Name = "Cbofontsize1", ;
		Top = 4
		*< END OBJECT: ClassLib="samples.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdBold' AS commandbutton WITH ;
		Caption = "B", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		Height = 23, ;
		Left = 227, ;
		Name = "cmdBold", ;
		ToolTipText = "Bold", ;
		Top = 4, ;
		Width = 25
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdColor' AS commandbutton WITH ;
		Caption = "C", ;
		ForeColor = 255,0,0, ;
		Height = 23, ;
		Left = 283, ;
		Name = "cmdColor", ;
		ToolTipText = "Color", ;
		Top = 4, ;
		Width = 25
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdItalic' AS commandbutton WITH ;
		Caption = "I", ;
		FontBold = .T., ;
		FontItalic = .T., ;
		FontName = "Courier New", ;
		FontSize = 9, ;
		Height = 23, ;
		Left = 255, ;
		Name = "cmdItalic", ;
		ToolTipText = "Italic", ;
		Top = 4, ;
		Width = 25
		*< END OBJECT: BaseClass="commandbutton" />

ENDDEFINE

DEFINE CLASS soundplayer AS control 
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="tmrCheckMode" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: closesound		&& Closes the loaded sound file and releases it's resources.
		*m: domci		&& Executes a MCI command.
		*m: getmcierror		&& Stores the last MCI error into properties of the class.
		*m: opensound		&& Opens the sound file.
		*m: pausesound		&& Pauses the currently playing sound.
		*m: playsound		&& Plays the loaded sound file.
		*m: setposition		&& Allows the user to set the position of the media file; Valid values are Start, End, or a number representing milliseconds.
		*m: showmcierror		&& Displays the result of the last MCI command in a messagebox.
		*p: autoopen		&& Specifies whether the video file specified should be automatically opened when the class is created.
		*p: autoplay		&& Specifies whether the video file should automatically play after opening.
		*p: autorepeat		&& If .T., video will continuously play
		*p: controlsource		&& Specifies the source of data to which an object is bound.
		*p: mcialias		&& Specifies the alias for the video file when calling MCI commands.  If empty, the name of the file is used.
		*p: mcierror		&& Specifies the result of the last MCI command executed.
		*p: mcierrorstring		&& Stores the error string from the last MCI command executed.
		*p: soundfile		&& Specifies the sound file associated with the Sound Player.
	*</DefinedPropArrayMethod>

	autoopen = .T.		&& Specifies whether the video file specified should be automatically opened when the class is created.
	autoplay = .T.		&& Specifies whether the video file should automatically play after opening.
	autorepeat = .T.		&& If .T., video will continuously play
	BorderWidth = 0
	controlsource = 		&& Specifies the source of data to which an object is bound.
	Height = 36
	mcialias = 		&& Specifies the alias for the video file when calling MCI commands.  If empty, the name of the file is used.
	mcierror = 0		&& Specifies the result of the last MCI command executed.
	mcierrorstring = 		&& Stores the error string from the last MCI command executed.
	Name = "soundplayer"
	Width = 33

	ADD OBJECT 'tmrCheckMode' AS timer WITH ;
		Height = 23, ;
		Left = 36, ;
		Name = "tmrCheckMode", ;
		Top = 0, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE closesound		&& Closes the loaded sound file and releases it's resources.
		
		*!* If sound is not already closed, then close it
		cCmd = ("STATUS " + THIS.MCIalias + " READY")
		IF THIS.doMCI(cCmd) = "true" THEN
			*!* If one is, close it
			cCMD = ("CLOSE " + THIS.MCIalias + " WAIT")
			THIS.doMCI(cCmd)
			IF THIS.MCIerror > 0 THEN
				THIS.showMCIerror
			ENDIF
			IF THIS.autoRepeat = .T. THEN
				THIS.tmrCheckMode.INTERVAL = 0
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		THIS.closeSound
	ENDPROC

	PROCEDURE domci		&& Executes a MCI command.
		LPARAMETERS cMCIcmd
		
		*!* This method takes a MCI command string and executes it using
		*!* the Windows API function mciSendString
		
		*!* If the function executes successfully, the result is returned.
		*!* Otherwise, the error string is returned.
		cRetString = space(80)
		nRetValue = mciSendString(cMCIcmd,@cRetString,len(cRetString),0)
		
		cErr = THIS.getMCIerror(nRetValue)
		IF nRetValue > 0
			RETURN CeRR
		ENDIF
		   
		RETURN TRIM(STRTRAN(cRetString,chr(0),""))
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		#DEFINE INVALID_CONTROLSOURCE_LOC "Invalid controlSource specified."
		
		LPARAMETERS nError, cMethod, nLine
		
		DO CASE
			CASE nError = 12 and cMethod = "opensound"
				messageBox(INVALID_CONTROLSOURCE_LOC)
			OTHERWISE
				ERROR (nError)
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE getmcierror		&& Stores the last MCI error into properties of the class.
		LPARAMETERS cError
		LOCAL lcErrorString,nError
		
		*!* This method is called from the doMCI to retrieve the last
		*!* MCI error string.
		*!* This function also saves the last error number and string
		*!* into properties associated with the form.
		
		nError=0
		IF TYPE("cError")="C"
		   IF LEFT(cError,7)="*ERROR*"
		      nError=val(substr(cError,8))
		   ENDIF
		ENDIF   
		
		IF TYPE("cError")="N"
		  nError=cError
		ENDIF
		
		cErrorString=SPACE(256)  
		=mciGetErrorString(nError,@cErrorString,len(cErrorString))
		
		THIS.MCIerror = nError
		THIS.MCIerrorString = cErrorString
		
		RETURN TRIM(CHRTRAN(cErrorString,CHR(0),""))
		
	ENDPROC

	PROCEDURE Init
		
		*!* This is the primary Windows API function that is used to 
		*!* send MCI commands
		DECLARE INTEGER mciSendString ;
		   IN WinMM.DLL ;
		   STRING cMCIString,;
		   STRING @cRetString,;
		   INTEGER nRetLength,;
		   INTEGER hInstance
		
		*!* This function allows us to retrieve the last MCI error that occured
		DECLARE INTEGER mciGetErrorString ;
		   IN WINMM.DLL ;
		   INTEGER nErrorno, ;
		   STRING @cBuffer, ;
		   INTEGER nBufSize
		   
		*!* When MCI plays a video, it creates its own Window.  By using
		*!* this Windows API function we can position this Window to be
		*!* in the same position as our Player rectangle on the form
		DECLARE integer SetWindowPos ;
			IN User32 ;
			integer, integer, integer, integer, integer, integer, integer
		
	ENDPROC

	PROCEDURE opensound		&& Opens the sound file.
		
		#DEFINE NO_SOURCE_SPECIFIED_LOC "No filename or control source specified!"
		
		
		*!* Get needed properties into variables
		IF EMPTY(THIS.controlSource) THEN
			cFileName = THIS.soundFile
			IF EMPTY(cFileName) THEN
				MESSAGEBOX(NO_SOURCE_SPECIFIED_LOC)
				RETURN
			ENDIF
		ELSE
			cFileName = ALLTRIM(&controlSource)
			IF EMPTY(cFileName) THEN
				RETURN
			ENDIF
		ENDIF
			
		cAlias = THIS.MCIalias
		IF EMPTY(cAlias) THEN
			cAlias = THIS.name
			THIS.MCIalias = cAlias
		ENDIF
		
		_SCREEN.MousePointer = 11
		
		*!* If sound is already loaded, then close it
		cCmd = ("STATUS " + cAlias + " READY")
		IF THIS.doMCI(cCmd) = "true" THEN
			*!* If one is, close it
			cCMD = ("CLOSE " + cAlias + " WAIT")
			THIS.doMCI(cCmd)
		ENDIF
		
		*!* Set up open MCI command into string variable
		cCmd = ('OPEN "' + cFileName + '" alias ' + cAlias + ' WAIT')
		
		THIS.doMCI(cCmd)
		
		*!* Check to see if MCI command succeeded
		IF THIS.MCIerror > 0 THEN
			messagebox(THIS.MCIerrorString)
			_SCREEN.MousePointer = 0
			RETURN
		ENDIF
		
		*!* Set the device to use milliseconds when setting/getting position
		THIS.doMCI("SET " + cAlias + " time format milliseconds")
		
		IF THIS.autoPlay = .T. THEN
			THIS.playSound
		ENDIF
		
		_SCREEN.MousePointer = 0
		
	ENDPROC

	PROCEDURE pausesound		&& Pauses the currently playing sound.
		
		cAlias = THIS.MCIalias
		
		*!* Check to see if there is media acutally playing
		IF THIS.doMCI("STATUS " + cAlias + " mode") = "playing" THEN
			*!* Yes there is, so execute the PAUSE MCI command
			THIS.doMCI("PAUSE " + cAlias)
			IF THIS.MCIerror > 0 THEN
				THIS.showMCIerror
			ENDIF
			IF THIS.autoRepeat = .T. THEN
				THIS.tmrCheckMode.INTERVAL = 0
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE playsound		&& Plays the loaded sound file.
		
		cAlias = THIS.MCIalias
		
		*!* First need to see if the media is at the end 
		*!* by comparing the total length with the current position
		nMediaLength = VAL(THIS.doMCI("STATUS " + cAlias + " length"))
		nMediaPosition = VAL(THIS.doMCI("STATUS " + cAlias + " position"))
		
		IF nMediaPosition >= nMediaLength THEN
			*!* The media is at the end, so we need to seek back to the start
			*!* of the clip before playing
			THIS.doMCI("SEEK " + cAlias + " to start WAIT")
		ENDIF
		
		*!* Now we can play the media
		THIS.doMCI("PLAY " + cAlias)
		IF THIS.MCIerror > 0 THEN
			THIS.showMCIerror
		ENDIF
		
		IF THIS.autoRepeat = .T. THEN
			THIS.tmrCheckMode.INTERVAL = 300
		ENDIF
	ENDPROC

	PROCEDURE Refresh
		
		IF THIS.autoOpen = .T. THEN
			THIS.openSound
		ENDIF
		
	ENDPROC

	PROCEDURE setposition		&& Allows the user to set the position of the media file; Valid values are Start, End, or a number representing milliseconds.
		PARAMETERS cPosition
		
		cAlias = THIS.MCIalias
		
		IF UPPER(cPosition) = "START" or UPPER(cPosition) = "END" THEN
			cPosCmd = "to " + cPosition
		ELSE
			nPosition = VAL(cPosition)
			IF EMPTY(nPosition) THEN
				RETURN
			ELSE
				*!* Check to make sure position is not greater than the length
				
				nMediaLength = VAL(THIS.doMCI("STATUS " + cAlias + " length"))
				IF nMediaLength < nPosition THEN
					RETURN
				ELSE
					cPosCmd = "to " + STR(nPosition)
				ENDIF
			ENDIF
		ENDIF
		
		*!* Make sure video is loaded
		cCmd = ("STATUS " + cAlias + " READY")
		IF THIS.doMCI(cCmd) = "true" THEN
			cCmd = "SEEK " + cAlias + " " + cPosCmd
			THIS.doMCI(cCmd)
		ENDIF
	ENDPROC

	PROCEDURE showmcierror		&& Displays the result of the last MCI command in a messagebox.
		MESSAGEBOX(STR(THIS.MCIerror) + ": " + THIS.MCIerrorString)
		
	ENDPROC

	PROCEDURE tmrCheckMode.Timer
		
		cCmd = ("STATUS " + THIS.PARENT.MCIalias + " MODE")
		IF THIS.PARENT.doMCI(cCmd) = "stopped" THEN
			THIS.PARENT.playSound
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS stopwatch AS container 		&& stop watch with start, stop, and reset methods
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="watch.bmp" ClassIcon="watch.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="tmrSWatch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrSWatch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrSWatch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSeparator1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSeparator2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblhours" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMinutes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSeconds" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: increment		&& increment the stopwatch display
		*m: reset		&& ,Property Description will appear here.
		*m: start
		*m: stop
		*m: updatedisplay
		*p: elapsedseconds		&& The time displayed in the stopwatch in elapsed seconds.
		*p: nhour
		*p: nmin
		*p: nsec
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nhour,nmin,nsec
	BackStyle = 0
	BorderWidth = 0
	elapsedseconds = 0		&& The time displayed in the stopwatch in elapsed seconds.
	Height = 21
	Name = "stopwatch"
	nhour = 0
	nmin = 0
	nsec = 0
	Width = 60
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'lblhours' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "00", ;
		FontBold = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 6, ;
		Name = "lblhours", ;
		Top = 5, ;
		Width = 14
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMinutes' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "00", ;
		FontBold = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 21, ;
		Name = "lblMinutes", ;
		Top = 5, ;
		Width = 14
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSeconds' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "00", ;
		FontBold = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 37, ;
		Name = "lblSeconds", ;
		Top = 5, ;
		Width = 14
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSeparator1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = ":", ;
		FontBold = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 18, ;
		Name = "lblSeparator1", ;
		Top = 4, ;
		Width = 5
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSeparator2' AS label WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = ":", ;
		FontBold = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 33, ;
		Name = "lblSeparator2", ;
		Top = 4, ;
		Width = 11
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'tmrSWatch' AS timer WITH ;
		Height = 25, ;
		Interval = 1000, ;
		Left = 66, ;
		Name = "tmrSWatch", ;
		Top = 0, ;
		Width = 25
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'tmrSWatch' AS timer WITH ;
		Height = 25, ;
		Interval = 1000, ;
		Left = 66, ;
		Name = "tmrSWatch", ;
		Top = 0, ;
		Width = 25
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'tmrSWatch' AS timer WITH ;
		Height = 25, ;
		Interval = 1000, ;
		Left = 52, ;
		Name = "tmrSWatch", ;
		Top = 2, ;
		Width = 25
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE increment		&& increment the stopwatch display
		THIS.nSec = THIS.nSec + 1
		
		IF THIS.nSec = 60
			THIS.nSec = 0
			THIS.nMin = THIS.nMin + 1
		ENDIF
		
		IF THIS.nMin = 60
			THIS.nMin = 0
			THIS.nHour = THIS.nHour + 1
		ENDIF
		THIS.UpdateDisplay
		THIS.ElapsedSeconds = (THIS.nHour * 3600) + ;
		                               (THIS.nMin * 60) + ;
		                                (This.nSec)
		
	ENDPROC

	PROCEDURE Init
		#DEFINE SEPARATOR_LOC ':'
		This.lblSeparator1.Caption = SEPARATOR_LOC
		This.lblSeparator2.Caption = SEPARATOR_LOC
	ENDPROC

	PROCEDURE reset		&& ,Property Description will appear here.
		This.tmrSWatch.Reset()
		This.nSec = 0
		This.nMin = 0
		This.nHour = 0
		This.UpdateDisplay()
		
	ENDPROC

	PROCEDURE start
		This.tmrSWatch.enabled = .T.
	ENDPROC

	PROCEDURE stop
		This.tmrSWatch.enabled = .f.
	ENDPROC

	PROCEDURE updatedisplay
		cSecDisplay = ALLTRIM(STR(This.nSec))
		cMinDisplay = ALLTRIM(STR(This.nMin))
		cHourDisplay = ALLTRIM(STR(This.nHour))
		
		This.lblSeconds.Caption = IIF(This.nSec < 10, "0" + cSecDisplay , cSecDisplay)
		This.lblMinutes.Caption = IIF(This.nMin < 10, "0" + cMinDisplay , cMinDisplay)
		This.lblHours.Caption = IIF(This.nHour < 10, "0" + cHourDisplay , cHourDisplay)
		
	ENDPROC

	PROCEDURE tmrSWatch.Timer
		THIS.Parent.Increment
	ENDPROC

	PROCEDURE tmrSWatch.Timer
		THIS.Parent.nSec = THIS.Parent.nSec + 1
		
		IF THIS.Parent.nSec = 60
			THIS.Parent.nSec = 0
			THIS.Parent.nMin = THIS.Parent.nMin + 1
		ENDIF
		
		IF THIS.Parent.nMin = 60
			THIS.Parent.nMin = 0
			THIS.Parent.nHour = THIS.Parent.nHour + 1
		ENDIF
		THIS.Parent.UpdateDisplay
		THIS.Parent.ElapsedSeconds = (THIS.Parent.nHour * 3600) + ;
		                               (THIS.Parent.nMin * 60) + ;
		                                (This.Parent.nSec)
		
	ENDPROC

	PROCEDURE tmrSWatch.Timer
		THIS.Parent.nSec = THIS.Parent.nSec + 1
		
		IF THIS.Parent.nSec = 60
			THIS.Parent.nSec = 0
			THIS.Parent.nMin = THIS.Parent.nMin + 1
		ENDIF
		
		IF THIS.Parent.nMin = 60
			THIS.Parent.nMin = 0
			THIS.Parent.nHour = THIS.Parent.nHour + 1
		ENDIF
		THIS.Parent.UpdateDisplay
		THIS.Parent.ElapsedSeconds = (THIS.Parent.nHour * 3600) + ;
		                               (THIS.Parent.nMin * 60) + ;
		                                (This.Parent.nSec)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tbrediting AS toolbar 
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboFonts" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Separator3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboSizes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Separator1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkBold" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkItalic" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUnderline" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Separator2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboColor" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: --		&& applies to all controls
		*p: nappliesto		&& 1 -- applies to current control
	*</DefinedPropArrayMethod>

	Caption = "Editing"
	Height = 31
	Left = 0
	Name = "tbrediting"
	nappliesto = 1		&& 1 -- applies to current control
	Top = 0
	Width = 339

	ADD OBJECT 'cboColor' AS combobox WITH ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 265, ;
		Name = "cboColor", ;
		Style = 2, ;
		ToolTipText = "ForeColor and BackColor", ;
		Top = 5, ;
		Value = 0, ;
		Width = 69
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboFonts' AS cbofontname WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 5, ;
		Name = "cboFonts", ;
		Top = 5, ;
		Width = 125
		*< END OBJECT: ClassLib="samples.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboSizes' AS cbofontsize WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 135, ;
		Name = "cboSizes", ;
		Top = 5
		*< END OBJECT: ClassLib="samples.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkBold' AS checkbox WITH ;
		Caption = "B", ;
		FontBold = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 184, ;
		Name = "chkBold", ;
		Style = 1, ;
		ToolTipText = "Bold", ;
		Top = 5, ;
		Value = .F., ;
		Width = 26
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkItalic' AS checkbox WITH ;
		Caption = "I", ;
		FontItalic = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 209, ;
		Name = "chkItalic", ;
		Style = 1, ;
		ToolTipText = "Italic", ;
		Top = 5, ;
		Value = .F., ;
		Width = 26
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkUnderline' AS checkbox WITH ;
		Caption = "U", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		FontUnderline = .T., ;
		Height = 22, ;
		Left = 234, ;
		Name = "chkUnderline", ;
		Style = 1, ;
		ToolTipText = "Underline", ;
		Top = 5, ;
		Value = .F., ;
		Width = 26
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'Separator1' AS separator WITH ;
		Height = 22, ;
		Left = 184, ;
		Name = "Separator1", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />

	ADD OBJECT 'Separator2' AS separator WITH ;
		Height = 22, ;
		Left = 265, ;
		Name = "Separator2", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />

	ADD OBJECT 'Separator3' AS separator WITH ;
		Height = 22, ;
		Left = 135, ;
		Name = "Separator3", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />
	
	PROCEDURE Destroy
		This.Visible = .F.
		
	ENDPROC

	PROCEDURE Refresh
		LPARAMETERS oSource
		
		DO CASE
			CASE THIS.nAppliesTo = 2 && text and edit boxes
				IF TYPE("_SCREEN.ActiveForm") = 'O'
					oForm = _SCREEN.ActiveForm
				ELSE
					RETURN
				ENDIF
				FOR i = 1 to oForm.ControlCount
					IF oForm.Controls(i).BaseClass$"Textbox Editbox"
						THIS.cboFonts.Value = oForm.Controls(i).FontName
						THIS.cboSizes.FillList(THIS.cboFonts.Value)
						THIS.cboSizes.Value = STR(oForm.Controls(i).FontSize)
						THIS.chkBold.Value = oForm.Controls(i).FontBold
						THIS.chkItalic.Value = oForm.Controls(i).FontItalic
						THIS.chkUnderline.Value = oForm.Controls(i).FontUnderline
						EXIT
					ENDIF
				ENDFOR
			OTHERWISE
				IF TYPE("oSource") != 'O'
					RETURN
				ENDIF
				THIS.cboFonts.Value = oSource.FontName
				THIS.cboSizes.FillList(THIS.cboFonts.Value)
				THIS.cboSizes.Value = STR(oSource.FontSize)
				THIS.chkBold.Value = oSource.FontBold
				THIS.chkItalic.Value = oSource.FontItalic
				THIS.chkUnderline.Value = oSource.FontUnderline
		ENDCASE
	ENDPROC

	PROCEDURE cboColor.Init
		
		#DEFINE AVAIL_COLORS_LOC "Colors"
		#DEFINE SET_FORE_COLOR_LOC "Set ForeColor..."
		#DEFINE SET_BACK_COLOR_LOC "Set BackColor..."
		
		THIS.AddItem(AVAIL_COLORS_LOC)
		THIS.AddItem(SET_FORE_COLOR_LOC)
		THIS.AddItem(SET_BACK_COLOR_LOC)
		THIS.ListIndex = 1
		
	ENDPROC

	PROCEDURE cboColor.InteractiveChange
		IF TYPE("_SCREEN.ActiveForm") = 'O'
			oForm = _SCREEN.ActiveForm
			oControl = oForm.ActiveControl
		ELSE
			RETURN
		ENDIF
		DO CASE 
			CASE This.Value = 1
				RETURN
			CASE This.Value = 2 && Get ForeColor
				nForeColor = GETCOLOR()
				IF nForeColor > -1
				DO CASE
					CASE THISFORM.nAppliesTo = 1 && current control
						IF TYPE("oControl.ForeColor") = "N"
							oControl.ForeColor = nForeColor
						ELSE
							IF TYPE("oControl.ItemForeColor") = "N"
								oControl.ItemForeColor = nForeColor
							ENDIF
						ENDIF
					CASE THISFORM.nAppliesTo = 2 && text and edit boxes
						oForm.SetAll('ForeColor', nForeColor, 'TEXTBOX')
						oForm.SetAll('ForeColor', nForeColor, 'EDITBOX')
					
					CASE THISFORM.nAppliesTo = 3 && All controls
						oForm.SetAll('ForeColor', nForeColor)
				ENDCASE
				ENDIF
		
			CASE This.Value = 3 && Get BackColor
				nBackColor = GETCOLOR()
				IF nBackColor > -1
				DO CASE
					CASE THISFORM.nAppliesTo = 1 && current control
						IF TYPE("oForm.ActiveControl.BackColor") = "N"
							oForm.ActiveControl.BackColor = nBackColor
						ELSE
							IF TYPE("oForm.ActiveControl.ItemBackColor") = "N"
								oForm.ActiveControl.ItemBackColor = nBackColor
							ENDIF
						ENDIF
					CASE THISFORM.nAppliesTo = 2 && text and edit boxes
						oForm.SetAll('BackColor', nBackColor, 'TEXTBOX')
						oForm.SetAll('BackColor', nBackColor, 'EDITBOX')
					
					CASE THISFORM.nAppliesTo = 3 && All controls
						oForm.SetAll('BackColor', nBackColor)
				ENDCASE
				ENDIF		
		ENDCASE
		THIS.Value = 1
		
		
	ENDPROC

	PROCEDURE cboFonts.InteractiveChange
		LOCAL oForm, oControl
		IF TYPE("_SCREEN.ActiveForm") = "O" AND TYPE("_SCREEN.ActiveForm.ActiveControl") = "O"
			oForm = _SCREEN.ActiveForm
			oControl = oForm.ActiveControl
		ELSE
			RETURN
		ENDIF
		
		DO CASE
			CASE THIS.Parent.nAppliesTo = 1	&& Current Control
				oControl.FontName = This.Value
				
			CASE THIS.Parent.nAppliesTo = 2	&& All textboxes and editboxes
				oForm.SetAll('FontName', This.Value, 'TEXTBOX')
				oForm.SetAll('FontName', This.Value, 'EDITBOX')
			
			*==================================================================
			* comment out the previous 2 lines and uncomment the following lines
			* if you want to affect all controls with a baseclass of textbox 
			* or editbox.
			*------------------------------------------------------------------
			*FOR i = 1 to oForm.ControlCount
			*  <find out what the baseclass property is to avoid having to UPPER>
			*	IF UPPER(oForm.Controls(i).BaseClass) = 'TEXTBOX' OR ;
			*		UPPER(oForm.Controls(i).BaseClass) = 'EDITBOX'
			*		oForm.Controls(i).FontName = THIS.Value
			*	ENDIF
			*ENDFOR
			*==================================================================
		
			CASE THIS.Parent.nAppliesTo = 3	&& All Controls
				oForm.SetAll('FontName', This.Value)
		
		ENDCASE
		
		THIS.Parent.cboSizes.FillList(THIS.Value)
		THIS.Parent.Refresh(oControl)
		
		
	ENDPROC

	PROCEDURE cboSizes.Error
		LPARAMETERS nError, cMethod, nLine
		#define NUM_LOC "Error Number: "
		#define PROG_LOC "Procedure: "
		#define MSG_LOC "Error Message: "
		#define CR_LOC CHR(13)
		#define BADSIZE_LOC "The control doesn't support the selected fontsize."
		
		DO CASE
			CASE nError = 1881 && Fontsize invalid for the control
				WAIT WINDOW BADSIZE_LOC TIMEOUT 2
				IF TYPE("Application.ActiveForm.ActiveControl") = "O"
					THIS.Parent.Refresh(Application.ActiveForm.ActiveControl)
				ENDIF
			
			OTHERWISE
			*-----------------------------------------------------------
			* Display information about an unanticipated error.
			*-----------------------------------------------------------
				lcMsg = NUM_LOC + ALLTRIM(STR(nError)) + CR_LOC + CR_LOC + ;
						MSG_LOC + MESSAGE( )+ CR_LOC + CR_LOC + ;
						PROG_LOC + PROGRAM(1)
				lnAnswer = MESSAGEBOX(lcMsg, 2+48+512)
				DO CASE
					CASE lnAnswer = 3 &&Abort
						CANCEL
					CASE lnAnswer = 4 &&Retry
						RETRY
					OTHERWISE
						RETURN
				ENDCASE
		ENDCASE
		
	ENDPROC

	PROCEDURE cboSizes.InteractiveChange
		IF TYPE("_SCREEN.ActiveForm") = 'O'
			oForm = _SCREEN.ActiveForm
		ELSE
			RETURN
		ENDIF
		
		DO CASE
			CASE THIS.Parent.nAppliesTo = 1	&& Current Control
				oForm.ActiveControl.FontSize = VAL(THIS.Value)
				
			CASE THIS.Parent.nAppliesTo = 2	&& All textboxes and editboxes
				oForm.SetAll('FontSize', VAL(THIS.Value), 'TEXTBOX')		
				oForm.SetAll('FontSize', VAL(THIS.Value), 'EDITBOX')		
			
			CASE THIS.Parent.nAppliesTo = 3	&& All Controls
				oForm.SetAll('FontSize', VAL(THIS.Value))
		
		ENDCASE
		
	ENDPROC

	PROCEDURE chkBold.InteractiveChange
		IF TYPE("_SCREEN.ActiveForm") = 'O'
			oForm = _SCREEN.ActiveForm
		ELSE
			RETURN
		ENDIF
		
		DO CASE
			CASE THIS.Parent.nAppliesTo = 1	&& Current Control
				oForm.ActiveControl.FontBold = THIS.Value
				
			CASE THIS.Parent.nAppliesTo = 2	&& All textboxes and editboxes
				oForm.SetAll('FontBold', THIS.Value, 'TEXTBOX')		
				oForm.SetAll('FontBold', THIS.Value, 'EDITBOX')		
			
			CASE THIS.Parent.nAppliesTo = 3	&& All Controls
				oForm.SetAll('FontBold', THIS.Value)
		ENDCASE
		
	ENDPROC

	PROCEDURE chkItalic.InteractiveChange
		IF TYPE("_SCREEN.ActiveForm") = 'O'
			oForm = _SCREEN.ActiveForm
		ELSE
			RETURN
		ENDIF
		
		DO CASE
			CASE THIS.Parent.nAppliesTo = 1	&& Current Control
				oForm.ActiveControl.FontItalic = THIS.Value
				
			CASE THIS.Parent.nAppliesTo = 2	&& All textboxes and editboxes
				oForm.SetAll('FontItalic', THIS.Value, 'TEXTBOX')		
				oForm.SetAll('FontItalic', THIS.Value, 'EDITBOX')		
			
			CASE THIS.Parent.nAppliesTo = 3	&& All Controls
				oForm.SetAll('FontItalic', THIS.Value)
		
		ENDCASE
		
	ENDPROC

	PROCEDURE chkUnderline.InteractiveChange
		IF TYPE("_SCREEN.ActiveForm") = 'O'
			oForm = _SCREEN.ActiveForm
		ELSE
			RETURN
		ENDIF
		
		DO CASE
			CASE THIS.Parent.nAppliesTo = 1	&& Current Control
				oForm.ActiveControl.FontUnderline = THIS.Value
				
			CASE THIS.Parent.nAppliesTo = 2	&& All textboxes and editboxes
				oForm.SetAll('FontUnderline', THIS.Value, 'TEXTBOX')		
				oForm.SetAll('FontUnderline', THIS.Value, 'EDITBOX')		
			
			CASE THIS.Parent.nAppliesTo = 3	&& All Controls
				oForm.SetAll('FontUnderline', THIS.Value)
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS videoframe AS control 
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="tmrCheckMode" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: closevideo		&& Closes the video file and releases all resources.
		*m: domci		&& Executes a MCI command.
		*m: getmcierror		&& Stores the last MCI error into properties of the class.
		*m: openvideo		&& Opens the video file and shows it.
		*m: pausevideo		&& Pauses a currently playing video.
		*m: playvideo		&& Plays the currently loaded video.
		*m: setposition		&& Allows the user to set the position of the media file; Valid values are Start, End, or a number representing milliseconds.
		*m: showmcierror		&& Displays the result of the last MCI command in a messagebox.
		*p: autoopen		&& Specifies whether the video file specified should be automatically opened when the class is created.
		*p: autoplay		&& Specifies whether the video file should automatically play after opening.
		*p: autorepeat		&& If .T., video will continuously play
		*p: controlsource		&& Specifies the source of data to which an object is bound.
		*p: mcialias		&& Specifies the alias for the video file when calling MCI commands.  If empty, the name of the file is used.
		*p: mcierror		&& Specifies the result of the last MCI command executed.
		*p: mcierrorstring		&& Stores the error string from the last MCI command executed.
		*p: videofile		&& Specifies the video file associated with the Video Frame.
	*</DefinedPropArrayMethod>

	autoopen = .T.		&& Specifies whether the video file specified should be automatically opened when the class is created.
	autoplay = .T.		&& Specifies whether the video file should automatically play after opening.
	autorepeat = .T.		&& If .T., video will continuously play
	controlsource = 		&& Specifies the source of data to which an object is bound.
	Height = 133
	mcialias = 		&& Specifies the alias for the video file when calling MCI commands.  If empty, the name of the file is used.
	mcierror = 0		&& Specifies the result of the last MCI command executed.
	mcierrorstring = 		&& Stores the error string from the last MCI command executed.
	Name = "videoframe"
	videofile = 		&& Specifies the video file associated with the Video Frame.
	Width = 201

	ADD OBJECT 'tmrCheckMode' AS timer WITH ;
		Height = 23, ;
		Left = 120, ;
		Name = "tmrCheckMode", ;
		Top = 96, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE closevideo		&& Closes the video file and releases all resources.
		
		*!* If video is not already closed, then close it
		cCmd = ("STATUS " + THIS.MCIalias + " READY")
		IF THIS.doMCI(cCmd) = "true" THEN
			*!* If one is, close it
			cCMD = ("CLOSE " + THIS.MCIalias + " WAIT")
			THIS.doMCI(cCmd)
			IF THIS.MCIerror > 0 THEN
				THIS.showMCIerror
			ENDIF
			IF THIS.autoRepeat = .T. THEN
				THIS.tmrCheckMode.INTERVAL = 0
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		THIS.closeVideo
	ENDPROC

	PROCEDURE domci		&& Executes a MCI command.
		LPARAMETERS cMCIcmd
		
		*!* This method takes a MCI command string and executes it using
		*!* the Windows API function mciSendString
		
		*!* If the function executes successfully, the result is returned.
		*!* Otherwise, the error string is returned.
		cRetString = space(80)
		nRetValue = mciSendString(cMCIcmd,@cRetString,len(cRetString),0)
		
		cErr = THIS.getMCIerror(nRetValue)
		IF nRetValue > 0
			RETURN CeRR
		ENDIF
		   
		RETURN TRIM(STRTRAN(cRetString,chr(0),""))
		
	ENDPROC

	PROCEDURE Error
		#DEFINE INVALID_CONTROLSOURCE_LOC "Invalid controlSource specified."
		
		LPARAMETERS nError, cMethod, nLine
		
		DO CASE
			CASE nError = 12 and cMethod = "openvideo"
				messageBox(INVALID_CONTROLSOURCE_LOC)
			OTHERWISE
				ERROR (nError)
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE getmcierror		&& Stores the last MCI error into properties of the class.
		LPARAMETERS cError
		LOCAL lcErrorString,nError
		
		*!* This method is called from the doMCI to retrieve the last
		*!* MCI error string.
		*!* This function also saves the last error number and string
		*!* into properties associated with the form.
		
		nError=0
		IF TYPE("cError")="C"
		   IF LEFT(cError,7)="*ERROR*"
		      nError=val(substr(cError,8))
		   ENDIF
		ENDIF   
		
		IF TYPE("cError")="N"
		  nError=cError
		ENDIF
		
		cErrorString=SPACE(256)  
		=mciGetErrorString(nError,@cErrorString,len(cErrorString))
		
		THIS.MCIerror = nError
		THIS.MCIerrorString = cErrorString
		
		RETURN TRIM(CHRTRAN(cErrorString,CHR(0),""))
		
	ENDPROC

	PROCEDURE Init
		
		*!* This is the primary Windows API function that is used to 
		*!* send MCI commands
		DECLARE INTEGER mciSendString ;
		   IN WinMM.DLL ;
		   STRING cMCIString,;
		   STRING @cRetString,;
		   INTEGER nRetLength,;
		   INTEGER hInstance
		
		*!* This function allows us to retrieve the last MCI error that occured
		DECLARE INTEGER mciGetErrorString ;
		   IN WINMM.DLL ;
		   INTEGER nErrorno, ;
		   STRING @cBuffer, ;
		   INTEGER nBufSize
		   
		*!* When MCI plays a video, it creates its own Window.  By using
		*!* this Windows API function we can position this Window to be
		*!* in the same position as our Player rectangle on the form
		DECLARE integer SetWindowPos ;
			IN User32 ;
			integer, integer, integer, integer, integer, integer, integer
		
	ENDPROC

	PROCEDURE openvideo		&& Opens the video file and shows it.
		
		*!* Get needed properties into variables
		cControlSource = THIS.controlSource
		IF EMPTY(cControlSource) THEN
			cFileName = THIS.videoFile
			IF EMPTY(cFileName) THEN
				MESSAGEBOX("No filename specified or control source specified!")
				RETURN
			ENDIF
		ELSE
			cFileName = ALLTRIM(&cControlSource)
			IF EMPTY(cFileName) THEN
				RETURN
			ENDIF
		ENDIF
		
			
		cAlias = THIS.MCIalias
		IF EMPTY(cAlias) THEN
			cAlias = THIS.name
			THIS.MCIalias = cAlias
		ENDIF
		
		_SCREEN.MousePointer = 11
		
		*!* If video is already loaded, then close it
		cCmd = ("STATUS " + cAlias + " READY")
		IF THIS.doMCI(cCmd) = "true" THEN
			*!* If one is, close it
			cCMD = ("CLOSE " + cAlias + " WAIT")
			THIS.doMCI(cCmd)
		ENDIF
		
		* Returns Handle of Main VFP Window
		Main_hWnd = _VFP.hWnd
		
		* Get Handle of the form with FOXTOOLS.FLL
		cur_window = THISFORM.HWnd
		
		NullPointer = 0
		
		*!* Set up open MCI command into string variable
		cCmd = ('OPEN "' + cFileName + '" alias ' + cAlias + ;
		  ' style child parent ' + ALLTRIM(STR(cur_window)) + ' WAIT')
		
		THIS.doMCI(cCmd)
		
		*!* Check to see if MCI command succeeded
		IF THIS.MCIerror > 0 THEN
			messagebox(THIS.MCIerrorString)
			_SCREEN.MousePointer = 0
			RETURN
		ELSE
			*!* It does have visual media, so we need to set up the window
			*!* it will play in.
			
			*!* Get the window handle of the window playing the video
			cCmd = "status " + cAlias + " window handle wait"
			hWin = INT(VAL(THIS.doMCI(cCmd)))
		
			*!* Once we have the window handle, we need to position
			*!* the video window to be the same position and size
			*!* as our player rectangle on the form
			x1Pos = THIS.LEFT
			y1Pos = THIS.TOP
			x2Pos = x1Pos + THIS.WIDTH
			y2Pos = y1Pos + THIS.HEIGHT
		
			*!* Use the SetWindowPos Windows function to set position and size
			setWindowPos(hWin,0,x1Pos,y1Pos,x2Pos,y2Pos,0)
		
			*!* Everything's done, let's show the video
			cCmd = ("WINDOW " + cAlias + " state show")
			THIS.doMCI(cCmd)
		
		ENDIF
		
		*!* Set the device to use milliseconds when setting/getting position
		THIS.doMCI("SET " + cAlias + " time format milliseconds")
		
		IF THIS.autoPlay = .T. THEN
			THIS.playVideo
		ENDIF
		
		_SCREEN.MousePointer = 0
		
	ENDPROC

	PROCEDURE pausevideo		&& Pauses a currently playing video.
		
		cAlias = THIS.MCIalias
		
		*!* Check to see if there is media acutally playing
		IF THIS.doMCI("STATUS " + cAlias + " mode") = "playing" THEN
			*!* Yes there is, so execute the PAUSE MCI command
			THIS.doMCI("PAUSE " + cAlias)
			IF THIS.MCIerror > 0 THEN
				THIS.showMCIerror
			ENDIF
			IF THIS.autoRepeat = .T. THEN
				THIS.tmrCheckMode.INTERVAL = 0
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE playvideo		&& Plays the currently loaded video.
		
		cAlias = THIS.MCIalias
		
		*!* First need to see if the media is at the end 
		*!* by comparing the total length with the current position
		nMediaLength = VAL(THIS.doMCI("STATUS " + cAlias + " length"))
		nMediaPosition = VAL(THIS.doMCI("STATUS " + cAlias + " position"))
		
		IF nMediaPosition >= nMediaLength THEN
			*!* The media is at the end, so we need to seek back to the start
			*!* of the clip before playing
			THIS.doMCI("SEEK " + cAlias + " to start WAIT")
		ENDIF
		
		*!* Now we can play the media
		THIS.doMCI("PLAY " + cAlias)
		IF THIS.MCIerror > 0 THEN
			THIS.showMCIerror
		ENDIF
		
		IF THIS.autoRepeat = .T. THEN
			THIS.tmrCheckMode.INTERVAL = 100
		ENDIF
	ENDPROC

	PROCEDURE Refresh
		
		IF THIS.autoOpen = .T. THEN
			THIS.openVideo
		ENDIF
		
	ENDPROC

	PROCEDURE setposition		&& Allows the user to set the position of the media file; Valid values are Start, End, or a number representing milliseconds.
		PARAMETERS cPosition
		
		cAlias = THIS.MCIalias
		
		IF UPPER(cPosition) = "START" or UPPER(cPosition) = "END" THEN
			cPosCmd = "to " + cPosition
		ELSE
			nPosition = VAL(cPosition)
			IF EMPTY(nPosition) THEN
				RETURN
			ELSE
				*!* Check to make sure position is not greater than the length
				
				nMediaLength = VAL(THIS.doMCI("STATUS " + cAlias + " length"))
				IF nMediaLength < nPosition THEN
					RETURN
				ELSE
					cPosCmd = "to " + STR(nPosition)
				ENDIF
			ENDIF
		ENDIF
		
		*!* Make sure video is loaded
		cCmd = ("STATUS " + cAlias + " READY")
		IF THIS.doMCI(cCmd) = "true" THEN
			cCmd = "SEEK " + cAlias + " " + cPosCmd
			THIS.doMCI(cCmd)
		ENDIF
	ENDPROC

	PROCEDURE showmcierror		&& Displays the result of the last MCI command in a messagebox.
		MESSAGEBOX(STR(THIS.MCIerror) + ": " + THIS.MCIerrorString)
		
	ENDPROC

	PROCEDURE tmrCheckMode.Timer
		
		cCmd = ("STATUS " + THIS.PARENT.MCIalias + " MODE")
		IF THIS.PARENT.doMCI(cCmd) = "stopped" THEN
			THIS.PARENT.playVideo
		ENDIF
	ENDPROC

ENDDEFINE
